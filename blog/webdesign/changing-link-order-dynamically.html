<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8">
    <meta content="light dark" name="color-scheme">
    <meta content="width=device-width, initial-scale=1" name="viewport">

    <title>link要素の順序を後から変更する</title>

    <style>
      body {
        font-family: sans-serif;
        font-size: 112.5%;
        margin-block-end: 25svh;
      }

      pre {
        white-space: pre-wrap;
      }

      figure {
        margin-inline: 0;
      }

      img,
      svg {
        block-size: auto;
        max-inline-size: 100%;
      }
    </style>
  </head>

  <body>
    <p><time>2014-06-21</time></p>

    <h1>link要素の順序を後から変更する</h1>

    <p>ちょっとした事情があって干渉するルールを持つ二つの<code>link</code>要素を状況によってスワップさせたいことがあった。どちらかのみを書いておいて条件に合わせて差し替えるのが普通のアプローチだと思うけど、先読みさせたかったのであらかじめ両方共読み込ませておいて、<code>head</code>要素内での順序を変えてカスケーディング順序を変えるという方法で行った。動的に<code>link</code>要素の順序を変更すると、カスケーディングの順序に影響を与えるようだ。</p>

<p>Demo: <a href="/test/573.html">link Element Order</a></p>

<p>デモは<code>.test</code>の前景色を緑にするCSS・赤にするCSSの順で両方読み込み、後で緑にするCSSを<code>head</code>要素の最後に動かしている。だいたいのブラウザで意図した通りに緑になるようだ。考えて見れば当然とも言えるんだけど、やろうとすら考えたこともなかったのでちゃんとしてるんだなーという感想。</p>

<pre><code class="language-javascript">var elmHead = document.head;
var cssGreen = document.getElementById(&apos;green&apos;);
elmHead.appendChild(cssGreen.cloneNode());
elmHead.removeChild(cssGreen);</code></pre>

<p>クローンして追加してから削除するようにすると、大きな干渉がある時にもオーバーヘッドが最小限に抑えられると思う。元のノードの削除は遅延させても良いかもしれない。</p>

<hr>

<p>結局はその事情には別の方法で対処することになったので無駄な調査だったけど、なんかの時に思い出して使いたい。</p>
  </body>
</html>
