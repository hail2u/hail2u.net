<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8">
    <meta content="light dark" name="color-scheme">
    <meta content="same-origin" name="view-transition">
    <meta content="width=device-width, initial-scale=1" name="viewport">

    <title>スプレッド演算子を利用した配列同士の破壊的なマージ</title>

    <style>
      body {
        font-family: sans-serif;
        font-size: 112.5%;
        margin-block-end: 25svh;
      }

      pre {
        white-space: pre-wrap;
      }

      figure {
        margin-inline: 0;
      }

      img,
      svg {
        block-size: auto;
        max-inline-size: 100%;
      }
    </style>
  </head>

  <body>
    <p><time>2017-03-02</time></p>

    <h1>スプレッド演算子を利用した配列同士の破壊的なマージ</h1>

    <p>配列<code>a</code>へ配列<code>b</code>を破壊的にマージしたいが<code>let</code>を使わずに行いたいということで、<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator">スプレッド演算子</a>を使って<code>Array#push()</code>するようなコードを書いた。同じように<code>let</code>を使わずに書ける<code>Function#apply()</code>を使ったマージと違ってコードが短い。また引数由来の制限(実装依存)がない。</p>

<p><code>Array#concat()</code>を使って破壊的に配列をマージするコードは、通常、以下のように書かれる。破壊する場合は再代入するため、マージ先の配列は<code>let</code>を使い定義している。</p>

<pre><code class="language-javascript">let a = [0, 1, 2];
const b = [3, 4, 5];

a = a.concat(b);</code></pre>

<p>スプレッド演算子と<code>Array#push()</code>を使うと以下のように書ける。</p>

<pre><code class="language-javascript">const a = [0, 1, 2];
const b = [3, 4, 5];

a.push(...b);</code></pre>

<p>追加するだけで再代入は必要ないため、マージ先の配列を<code>const</code>で定義できるわけだ。</p>

<hr>

<p><a href="https://jsfiddle.net/knugsv4a/">単純な配列同士のマージ</a>だと、概ねスプレッド演算子を使ったコードの方が速いようだ。配列同士のマージを破壊的に行いたいという前提だとデメリットは特にないようだが、プロジェクトにおける<code>const</code>の扱いによっては良くない書き方とされるかもしれない。</p>
  </body>
</html>
