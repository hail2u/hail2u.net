<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
  xml:lang="ja"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:creativeCommons="http://backend.userland.com/creativeCommonsRssModule"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Weblog - Hail2u.net</title>
    <link>http://hail2u.net/blog/</link>
    <description>ウェブ制作やウェブ標準の話題が中心ですが、それに限らず備忘録や日々の記録までを含めることで、10年以上続けることができたウェブログです。Blosxomを使って作られています。</description>
    <language>ja</language>
    <managingEditor>hail2u@gmail.com (Kyo Nagashima)</managingEditor>
    <lastBuildDate>Wed, 24 Jun 2015 09:15:00 +0900</lastBuildDate>
    <generator>blosxom v2.1.2+dev</generator>
    <atom:link rel="self" href="http://hail2u.net/blog/feed"/>
    <atom:link rel="hub" href="https://pubsubhubbub.appspot.com/"/>
    <creativeCommons:license>http://creativecommons.org/licenses/by-nc/3.0/</creativeCommons:license>


    <item>
      <title>dns-prefetchとpreconnect、そしてprefetchやprerenderとpreloadの併記</title>
      <link>http://hail2u.net/blog/webdesign/dns-prefetch-preconnect-prefetch-prerender-preload.html</link>
      <description>2014年10月より標準化作業が公開されたResource Hints仕様により、既存のrel=dns-prefetchとrel=prefetch、そしてrel=prerenderは置き換えられる可能性がある。この置き換えが起こる可能性は決して高くはなさそうなので、実装されているもののままでも構わないと思うが、link要素のrel属性は複数の値を取ることができるので、同時指定しても良い。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/dns-prefetch-preconnect-prefetch-prerender-preload.html</guid>
      <pubDate>Wed, 24 Jun 2015 09:14:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p >2014年10月より標準化作業が公開された<a href="http://www.w3.org/TR/resource-hints/">Resource Hints仕様</a>により、既存の<code>rel=dns-prefetch</code>と<code>rel=prefetch</code>、そして<code>rel=prerender</code>は置き換えられる可能性がある。この置き換えが起こる可能性は決して高くはなさそうなので、実装されているもののままでも構わないと思うが、<code>link</code>要素の<code>rel</code>属性は複数の値を取ることができるので、同時指定しても良い。</p>

<p><code>rel=dns-prefetch</code>は<code>rel=preconnect</code>と完全に対応しているので、そのまま追加してやるだけになる。</p>

<pre><code >&lt;link
  href=&quot;//example.com&quot;
  rel=&quot;preconnect dns-prefetch&quot;&gt;
</code></pre>

<p><code>rel=prefetch</code>と<code>rel=prerender</code>はResource Hints仕様では<code>rel=preload</code>に統合される。事前にレンダリングまでするかどうかは<code>loadpolicy</code>属性を併用することで制御する。</p>

<pre><code >&lt;link
  href=&quot;http://example.com/fetch&quot;
  loadpolicy=&quot;next <mark>inert</mark>&quot;
  rel=&quot;preload prefetch&quot;&gt;
&lt;link
  href=&quot;http://example.com/render&quot;
  loadpolicy=&quot;next&quot;
  rel=&quot;preload prerender&quot;&gt;
</code></pre>

<p><code>rel=preload</code>はデフォルトで事前レンダリングを行うように支持するということになっており、それを無効にするためには<code>loadpolicy</code>属性で不活性やサボるなどという意味を持つ<code>inert</code>を指定する。つまり<code>rel=prefetch</code>と同じ挙動にしたい場合は<code>inert</code>を追加するということになる。</p>

<p><code>rel=preload</code>では他に<code>pr</code>属性を使って読み込みのプライオリティーを、<code>as</code>属性を使って読み込むリソースの形式を指定することもできるようになっている。特にウェブアプリではその動線の予測しやすさから、事前読み込みを駆使することになると思うので、<code>pr</code>属性を使ってうまくプライオリティーを制御することでより効果的なプリロードを行えることだろう。対して<code>as</code>属性での形式の指定は、画像やフォントの場合は択一式で提供することも多いはずなので、<code>html</code>以外を使う機会はあまりなさそうだ。</p>

<hr>

<p>あとは実際にうまく機能してくれるかどうかということになる。</p>

<aside >
<p>Chrome 43では開発者ツールのネットワークで<code>rel=dns-prefetch</code>や<code>rel=prefetch</code>の動作を確認でき、タスク マネージャ(Chromeのそれ)でレンダリング・プロセスが走っていることにより<code>rel=prerender</code>の動作を確認できる。</p>
</aside>

<p><code>rel=dns-prefetch</code>と<code>rel=preconnect</code>の併記は、Firefox 38及びChrome 43、Internet Explorer 11でちゃんと名前解決を行っているらしいことが確認できた。</p>

<p><code>rel=prefetch</code>と<code>rel=prerender</code>の両方に対応しているChrome 43とInternet Explorer 11ではどちらの併記方法もうまく動いているらしきことは確認できた。Firefox 38でも<code>rel=prefetch</code>の方の併記は問題ないようだった。</p>

<hr>

<p>速やかに<code>rel=preconnect</code>と<code>rel=preload</code>へと移行されるかというと大きく疑問が残る。Resource Hints仕様が現状の実装に比べて大きく強化されていることもそうだが、実装の足並みがバラバラで各自が制限や拡張を行っていることや、プリフェッチ系の機能への根強い抵抗があることもある。少なくともマルチ・プロセス化したFirefoxが<code>rel=prerender</code>相当の機能を実装するくらいになるまではどうなるかの予想は難しいだろう。</p>

<p>ともあれ現時点では併記しておくというのは悪くない。運良くResource Hints仕様へ揃う可能性もなくはないからだ。</p>]]></content:encoded>
    </item>

    <item>
      <title>Postcards from Penguin</title>
      <link>http://hail2u.net/blog/gadget/postcards-from-penguin.html</link>
      <description>ペンギン・ブックスの本のカバーをポストカードにしたものの100枚入りのセット、Postcards from Pengin: One Hundred Book Covers in One Boxを衝動買いした。Amazon.co.jpでタイポグラフィーの本を漁ってたら見つけた。100枚入っていてもだいたいは同じデザイン……なんだけれどもそこが異様に良い。2500円くらいだった。</description>
      <category>Gadget</category>
      <guid isPermaLink="true">http://hail2u.net/blog/gadget/postcards-from-penguin.html</guid>
      <pubDate>Tue, 23 Jun 2015 00:37:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure >
  <a href="http://www.amazon.co.jp/gp/product/0141044667/ref=as_li_ss_il?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=0141044667&amp;linkCode=as2&amp;tag=hail2unet-22"><img alt="Postcards from Penguin: One Hundred Book Covers in One Box" src="http://ecx.images-amazon.com/images/I/410OK-ej6sL.jpg" ></a>
</figure>

<p >ペンギン・ブックスの本のカバーをポストカードにしたものの100枚入りのセット、<a href="http://www.amazon.co.jp/gp/product/0141044667/ref=as_li_ss_il?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=0141044667&amp;linkCode=as2&amp;tag=hail2unet-22">Postcards from Pengin: One Hundred Book Covers in One Box</a>を衝動買いした。Amazon.co.jpでタイポグラフィーの本を漁ってたら見つけた。100枚入っていてもだいたいは同じデザイン……なんだけれどもそこが異様に良い。2500円くらいだった。</p>

<p><a href="https://instagram.com/p/4LPx-iqG1C/">ハードカバーの本のようなボックス</a>に入っている。背表紙のペンギンは安定の可愛さ。それほど高級感はないが、ボックスの表面はきちんとコーティングされていて、そう簡単にはヘタレなさそう。手触りも良い。</p>

<p>レビューをあさってたら50種類の2枚づつみたいな話もみつけたけれど、ちゃんと100種類ある(と思う)。ペンギンはいつも直立不動っていう訳じゃないとか、ちょっとの違いが楽しい。ペリカン・ブックスのものも結構な割合で混ざっていて、こちらは科学的な教養書が中心なので、ちょっとレトロ・フューチャーっぽい雰囲気がありこれもまた楽しい。</p>

<figure >
  <a href="http://hail2u.net/images/blog/postcards-from-penguin.jpg"><img alt="華麗なるギャツビーや嵐が丘、オデュッセイア、ペリカン・ブックスの教本などのレトロなカバーをポストカードにしたもの" height="1530" src="http://hail2u.net/images/blog/postcards-from-penguin.jpg" width="2720"></a>
  <figcaption>Postcards from Penguin</figcaption>
</figure>

<p>ばら撒いてるだけでも楽しくなってくる。額にうまく並べて飾れたら、下手なポスターよりもかっこよくなりそうだ。けど1枚25円もしないくらいなので、額の方が高くつく。切手を傷つけずに貼る時に使うヒンジとかをうまく使って工夫した方が良さそう。</p>

<hr>

<p>ポストカード集めの趣味をすごいバカにしていたけど、ハマりそうな感じがする。あまり手間と暇と金をかけずに収集感が得られて楽しい。</p>]]></content:encoded>
    </item>

    <item>
      <title>プリフェッチ中のリクエスト</title>
      <link>http://hail2u.net/blog/webdesign/fetching-when-prefetching.html</link>
      <description>特定のリソースをrel=prefetchを使ってプリフェッチしている最中に、何らかの形で新たにリクエストされるような状況になった場合、各ブラウザーはどういう挙動になるのかということを試していた。Firefox 38ではプリフェッチがそのまま続行され、新たなリクエストは発生しないという賢い挙動のようだ。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/fetching-when-prefetching.html</guid>
      <pubDate>Mon, 22 Jun 2015 09:42:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p >特定のリソースを<code>rel=prefetch</code>を使ってプリフェッチしている最中に、何らかの形で新たにリクエストされるような状況になった場合、各ブラウザーはどういう挙動になるのかということを試していた。Firefox 38ではプリフェッチがそのまま続行され、新たなリクエストは発生しないという賢い挙動のようだ。</p>

<p >View Demo: <a href="http://hail2u.net/pub/test/637.html">Fetching when Prefetching</a></p>

<p>デモでは<code>rel=prefetch</code>を使って<code>head</code>要素内で画像を先読みさせ、ドキュメントの読み込み完了の1秒後に動的に突っ込んだ<code>img</code>要素によりリクエストしてやろうとしている。開発者ツールなどでネットワーク状況を確認することで、どういう挙動になるか確認できる。</p>

<p>Firefox 38ではプリフェッチがそのまま続行され、新たにリクエストを発生せずに画像が挿入される。対してChrome 43とInternet Explorer 11ではプリフェッチがそのまま続行された上で、<code>img</code>要素を追加した時にもリクエストが走るようになり、プリフェッチは完全に無駄になる。</p>

<hr>

<p>主に同じページで使われるリソースを想定した<a href="https://www.chromium.org/spdy/link-headers-and-server-hint/link-rel-subresource"><code>rel=subresource</code>という別のヒント</a>が考えられていることや、より正確に制御することが可能になる<a href="http://www.w3.org/TR/resource-hints/">Resource Hints仕様(これでは<code>rel=preload</code>になる)</a>が作られていることを踏まえると、<code>rel=prefetch</code>他は現状の実装のままで、仕様に従った実装が新たに追加されそうだ。少なくとも<code>rel=prefetch</code>がFirefox 38の挙動に揃うことはなさそうだ。</p>]]></content:encoded>
    </item>

    <item>
      <title>WebhookからPubSubHubbubへの翻訳</title>
      <link>http://hail2u.net/blog/rss/webhook-to-pubsubhubbub.html</link>
      <description>少し前に公開されたIFTTTのMakerチャンネルを使って、GitHubリポジトリーのWebhookをPubSubHubbubの公開POSTリクエストに翻訳するようにした。GETを使った公開リクエストがあまり行儀が良くなさそうなことが前から気になっていたので、Makerチャンネルを使えば良いかなと試したところうまくいった。</description>
      <category>RSS</category>
      <guid isPermaLink="true">http://hail2u.net/blog/rss/webhook-to-pubsubhubbub.html</guid>
      <pubDate>Sun, 21 Jun 2015 07:13:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p >少し前に公開された<a href="https://ifttt.com/">IFTTT</a>の<a href="https://ifttt.com/maker">Makerチャンネル</a>を使って、GitHubリポジトリーのWebhookをPubSubHubbubの公開POSTリクエストに翻訳するようにした。<a href="http://hail2u.net/blog/internet/publishing-feed-via-pubsubhubbbub-using-github-webhooks.html">GETを使った公開リクエスト</a>があまり行儀が良くなさそうなことが前から気になっていたので、Makerチャンネルを使えば良いかなと試したところうまくいった。</p>

<section>
<h2>Makerチャンネルの有効化</h2>

<p>まずはMakerチャンネルのページへ行き、Connectボタンを押す。するとユーザーごとに専用のエンドポイントURLが作成されるので、How to Trigger Eventsというリンクをクリックして、それを確認しておく。</p>

<pre>https://maker.ifttt.com/trigger/{event}/with/key/{secret_key}
</pre>

<p>エンドポイントURLはこのような形になっている。<code>{event}</code>は後ほど好きに指定することになる。<code>{secret key}</code>はユーザーごとに発行されるユニークな文字列に置き換えられて表示される。第三者にバレるとまずそうなので、気を付けた方が良い(再生成することは可能)。</p>
</section>

<section>
<h2>GitHub Pages側の準備</h2>

<p>各リポジトリーの設定からWebhooks &amp; Servicesのページにアクセスし、Add Webhookボタンを押す。Payload URLにIFTTTのMakerチャンネルで作成された専用のエンドポイントURLを指定する。ここではGitHub PagesがビルドされたらPubSubHubbubで公開したいので、<code>{event}</code>は<code>page_build</code>にしておいた。GitHubリポジトリー側のイベントに対応させた名前にすると良いだろう。データを受け取ってゴニョゴニョするわけではないのでContent typeはどちらでも良いが、Secretは指定する必要がある(と思う)。</p>

<p>イベントはPage builtのみに絞っておくと良いだろう。</p>
</section>

<section>
<h2>レシピの作成</h2>

<p>Trigger側では先ほどGitHubリポジトリー側で指定したエンドポイントURLで使ったイベント名を指定する(ここでは<code>page_build</code>)。Action側では、以下のように指定すれば良い。</p>

<figure>
<table>
<thead>
<tr>
<th>フィールド</th>
<th>値</th>
</tr>
</thead>
<tbody>
<tr>
<td>URL</td>
<td>https://pubsubhubbub.appspot.com/</td>
</tr>
<tr>
<td>Method</td>
<td>POST</td>
</tr>
<tr>
<td>Content Type</td>
<td>application/x-www-form-urlencoded</td>
</tr>
<tr>
<td>Body</td>
<td>hub.mode=publish&amp;hub.url=http:%2F%2Fexample.com%2Ffeed</td>
</tr>
</tbody>
</table>
<figcaption>Action: Make a web request</figcaption>
</figure>

<p>Bodyフィールドで指定するRSSフィードのURL以外は同じで良いはずだ。Bodyフィールドでは自前でURLエンコードして指定しているが<code>&lt;&lt;&lt;</code>と<code>&gt;&gt;&gt;</code>で生URLを括るときっとURLエンコードされるだろう。</p>
</section>

<hr>

<p>これでGitHubリポジトリーの<code>gh-pages</code>ブランチへpushしGitHub Pagesのビルドを走らせると、一連の動作が確認できる。</p>

<p>GitHubリポジトリー側では、該当Webhookの管理画面にRecent Deliveriesというログが残っているので、そこでIFTTT側から<code>200</code>が帰っていることを確認することでリクエストが成功していることを確認できる。IFTTTのレシピ側では、Personal Recipe triggeredというログで、レシピが走りPubSubHubbubハブへのリクエストが成功していることを確認できる。更にGoogleのPubSubHubbubハブに用意されている<a href="https://pubsubhubbub.appspot.com/publish">Publisher Diagnostics</a>を使ってRSSフィードのURLを調べると、最後に記事を受け取った時刻と内容がわかるので、それを照らし合わせることで公開がうまくいっているか確認できる。</p>

<p>気になる人はFeedlyなどPubSubHubbubによる購読に対応しているフィード・リーダーを使うと公開即反映されているかも確認することができる。</p>

<hr>

<p>某アプリのおかげでRSSフィードが本来想定されていたような機械的に処理することのできるフォーマットのコンテンツとして復権する可能性がある。それと同時にポーリングではないPubSubHubbubによる公開と購読の重要性も上がるのではないかと考えられる。折に触れPubSubHubbubに言及することにより、少しでもPubSubHubbubによる公開を行ってくれるウェブログ(とウェブログ・ホスティング・サービス)が増えることに期待したい。</p>]]></content:encoded>
    </item>

    <item>
      <title>夢</title>
      <link>http://hail2u.net/blog/misc/dreaming-20150620.html</link>
      <description>湯船で丸々一本漏らす。あわてて手桶ですくい、トイレに流そうと風呂から出たらおばあちゃん(故人)に見つかる。そのまま正座させられ説教をされる。おばあちゃんには怒られたことがなかったので、すごいショックを受けつつ、とにかく服を着たかった。途中で「体拭いて服着ていい？」って聞いたら、「良いよ」ってニッコリ笑って返事してくれて、そのまますうっと蒸発するみたいに消えた。</description>
      <category>Misc.</category>
      <guid isPermaLink="true">http://hail2u.net/blog/misc/dreaming-20150620.html</guid>
      <pubDate>Sat, 20 Jun 2015 06:24:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p >湯船で丸々一本漏らす。あわてて手桶ですくい、トイレに流そうと風呂から出たらおばあちゃん(故人)に見つかる。そのまま正座させられ説教をされる。おばあちゃんには怒られたことがなかったので、すごいショックを受けつつ、とにかく服を着たかった。途中で「体拭いて服着ていい？」って聞いたら、「良いよ」ってニッコリ笑って返事してくれて、そのまますうっと蒸発するみたいに消えた。</p>

<p>なお現実世界では漏らしていなかった。</p>]]></content:encoded>
    </item>

    <item>
      <title>レイ → ← アウト</title>
      <link>http://hail2u.net/blog/webdesign/layout-changes-20150618.html</link>
      <description>ロゴの形状を変えたら広い画面のマルチカラムではずいぶんとバランスが悪くなった。そうでもないと思っていたけれど日に日に気になり度が増してきたため、レイアウトの基本を少し変更することにした。広い画面ではロゴを含めてコンテンツはメインカラムの左寄せに、サブカラムの中身は右寄せにするようにし、両者が詰まりすぎないようにその間を少し広くしてバランスをとった。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/layout-changes-20150618.html</guid>
      <pubDate>Fri, 19 Jun 2015 08:23:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p >ロゴの形状を変えたら広い画面のマルチカラムではずいぶんとバランスが悪くなった。そうでもないと思っていたけれど日に日に気になり度が増してきたため、レイアウトの基本を少し変更することにした。広い画面ではロゴを含めてコンテンツはメインカラムの左寄せに、サブカラムの中身は右寄せにするようにし、両者が詰まりすぎないようにその間を少し広くしてバランスをとった。</p>

<p>本当はカラムの間の中央にロゴを置きたいのだけど、グローバル・ナビゲーションの位置が難しい。そのまま右端だとヘッダーのバランスは良いものの、他のコンテンツとの一貫性に欠ける。左に浮かせた場合はロゴが左による分、ヘッダーだけずれているような印象になる。</p>

<p>グローバル・ナビゲーションを左右に分割してやるのが良さそうかなと調節しているところだ。これだとバランスは取れるが、CSSが異様に複雑になる。ロゴを浮かせて、グローバル・ナビゲーションをメインカラムに置いた方が良いのかもしれない。</p>]]></content:encoded>
    </item>

    <item>
      <title>外国語の読み方</title>
      <link>http://hail2u.net/blog/misc/foreign-words-pronunciation.html</link>
      <description>外国語の読み方はしゃべる人の立場としゃべる相手の想定によって変わってくる。大雑把に有識者やエバンジェリストなどと呼ばれる立場の人達は、なるべく誤解を広めないようにすることを重視して、正確に引き写した音で読んだ方が良い。一方、知識の拡散と質の向上を狙うわけではない人達は、同じような専門家に向けてしゃべるわけではないことも考え、まずは通じることを重要視して雑に読んでも良いはずだ。</description>
      <category>Misc.</category>
      <guid isPermaLink="true">http://hail2u.net/blog/misc/foreign-words-pronunciation.html</guid>
      <pubDate>Thu, 18 Jun 2015 09:43:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p >外国語の読み方はしゃべる人の立場としゃべる相手の想定によって変わってくる。大雑把に有識者やエバンジェリストなどと呼ばれる立場の人達は、なるべく誤解を広めないようにすることを重視して、正確に引き写した音で読んだ方が良い。一方、知識の拡散と質の向上を狙うわけではない人達は、同じような専門家に向けてしゃべるわけではないことも考え、まずは通じることを重要視して雑に読んでも良いはずだ。</p>

<p>少なからず両方を担うことがある人達の発音がブレるのは仕方がない。僕もよくブレているし、人を見て恐る々々読み方を変えていたりする。重要視すべきものが立場と相手で変わってきてしまうからということが表の理由だ。広める側としてちゃんとしたいという見栄と、専門家ではない人達へネイティブに近い発音でしゃべった時に通じなかった場合のあの微妙な空気と間、このあたりが裏の理由だろうか。</p>

<p>場合によって読み分けると書こうとすると、この記事のようなふわっとした、ある種本質的ではない話になってしまう。そのためウェブではどうしてもとがった意見の記事ばかりになる。とにかく正確にしろという理想または通じれば良いという現実のどちらかに振り切った記事しか読んだ記憶がない。</p>

<hr>

<p>もののついでに<a href="https://gist.github.com/hail2u/e19d227da90e6393505e">僕がCSSプロパティーをどう読んでいるか</a>を表にした。</p>

<p><code>width</code>は紆余曲折の結果「ウィドス」に落ち着き、もうそれ以外で読めなくなっている。「ウィズ」くらいの感覚で読んでると「え？何？」とか「あっフフッ」みたいな反応をされることが多かった。「ウィドゥス」になるとちょっと凝った感じに聞こえるらしく、失笑される機会が極端に増えつらかった。「ウィドス」はだいたい通じるので便利だ。そろそろ「ヘイト」派に流されそうだ。</p>

<p>しかし世界も徐々に変わってきていて、耳慣れない読み方でも互いに察してくれるようになってきた。これは日本人特有の事なかれ主義の発現ではなくて、ネイティブっぽい発音を小馬鹿にするような因習が消え始めたのだろう。</p>]]></content:encoded>
    </item>

    <item>
      <title>ウェブデザインのトレンドとその背景</title>
      <link>http://hail2u.net/blog/webdesign/webdesign-trends-and-their-backgrounds.html</link>
      <description>7 future web design trendsという記事を読んでいた。これらは既に(または元々)未来のトレンドじゃないという点を見なかったことにしても、構図を単純化しすぎなきらいがあり、トレンドっぽいものの紹介とその正当化という記事としか読めなかった。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/webdesign-trends-and-their-backgrounds.html</guid>
      <pubDate>Wed, 17 Jun 2015 10:59:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p ><a href="https://medium.com/@jowitaziobro/7-future-web-design-trends-fba93eba6355">7 future web design trends</a>という記事を読んでいた。これらは既に(または元々)<em>未来</em>のトレンドじゃないという点を見なかったことにしても、構図を単純化しすぎなきらいがあり、トレンドっぽいものの紹介とその正当化という記事としか読めなかった。</p>

<p>スクロールが中心になったことは確かで、そのことに最適化して無限スクロールを採用する(元記事の1)のは間違っていない。ファーストビュー信仰が最初から間違っていたことも事実で、ヒーロー・イメージなどと呼ばれるフルスクリーンの画像や動画の採用(元記事の2)は妥当に思える。しかしこの両者を同じスクロールという行為に対するトレンドとまとめるのは雑すぎる。</p>

<p>前者はスクロールという行為そのものと回線速度に最適化しているものだ。無限スクロールの利点は単にスクロールのみでコンテンツを読み進めていくことができるだけではなく、効率的なコンテンツの読み込みをもたらすことができる。むしろ<em>モバイル</em>というコンテキストで考えると、この回線速度における利点の方が重要だと言えるだろう。</p>

<p>後者はスクロールという行為を最優先させるユーザーに最適化したものだ。ウェブページを開くと人はスクロールするということを念頭に置くと、画面全体を支配する画像は特にデメリットにはならず、美しい包装紙のようにブランディングに良い影響を与えることができるだろう。しかしこのトレンドはモバイルに最適化されたものではない。なぜならばそういった画面全体を支配する画像はサイズが大きくなりがちで、回線速度に劣ることの多いモバイル環境では負担が大きくなりがちだからだ。</p>

<p>この筆者の言うところのトレンド自体はそれなりに受け入れられるし、既にトレンドになったと言って良いものだ。しかし、このようにモバイル対デスクトップという単純な構図に落としこむのは間違っている。少なくともウェブサイト制作に関わる人々はこういったトレンドの背景をもう少し掘り下げてみるべきだろう。</p>]]></content:encoded>
    </item>

    <item>
      <title>Chromeとpre要素</title>
      <link>http://hail2u.net/blog/webdesign/pre-on-chrome.html</link>
      <description>しばらく前から特定のフォントをpre要素へ指定すると、Chromeのみでほとんど意味のない縦スクロールバーが表れるという現象に悩まされている。とは言ってもWindows以外ではもはやスクロールバーが見えることはないので、事実上WindowsのChromeユーザーのみが影響を受ける。DirectWriteが有効になったChrome 37あたりから頻発するようになった印象だ。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/pre-on-chrome.html</guid>
      <pubDate>Tue, 16 Jun 2015 10:01:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure >
  <a href="http://hail2u.net/images/blog/pre-on-chrome.png"><img alt="謎の縦スクロールバー" height="627" src="http://hail2u.net/images/blog/pre-on-chrome.png" width="1200" ></a>
</figure>

<p >しばらく前から特定のフォントを<code>pre</code>要素へ指定すると、Chromeのみでほとんど意味のない縦スクロールバーが表れるという現象に悩まされている。とは言ってもWindows以外ではもはやスクロールバーが見えることはないので、事実上WindowsのChromeユーザーのみが影響を受ける。DirectWriteが有効になったChrome 37あたりから頻発するようになった印象だ。</p>

<p>修正は簡単で、上下どちらかに<code>padding</code>プロパティーを追加してやれば良い。</p>

<pre><code >pre {
  padding-bottom: 1px;
}
</code></pre>

<p>実害はあまりないように書いてしまったけれど、Mobile SafariなどWebKit系でもさり気なく発生しているような気がする。発生しても見た目は問題ない(スクロールバーが見えないので)が、ちょうどそこでスワイプしてスクロールしようとするとうまくスクロールされなかったりする。</p>

<p>とにかく再現条件がまったくわからない。このウェブサイトでは発生しているので、上記CSSによってアドホックに解決している。</p>]]></content:encoded>
    </item>

    <item>
      <title>パッケージのスコープ化</title>
      <link>http://hail2u.net/blog/software/scoped-npm-packages.html</link>
      <description>2015/04/15よりnpmレジストリーでパッケージのスコープ化が行えるようになった。パッケージのスコープ化は名前の衝突を回避することが主な目的のような取り上げられ方だが。僕は今まで色々な理由でnpmレジストリーへは非公開にしてGitHub経由でインストールすることを推奨していたようなパターンで使うのが良さそうだという感想を持った。</description>
      <category>Software</category>
      <guid isPermaLink="true">http://hail2u.net/blog/software/scoped-npm-packages.html</guid>
      <pubDate>Mon, 15 Jun 2015 11:46:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p >2015/04/15よりnpmレジストリーでパッケージのスコープ化が行えるようになった。パッケージのスコープ化は名前の衝突を回避することが主な目的のような取り上げられ方だが。僕は今まで色々な理由でnpmレジストリーへは非公開にしてGitHub経由でインストールすることを推奨していたようなパターンで使うのが良さそうだという感想を持った。</p>

<p><code>&quot;private&quot;: true</code>からスコープ化したパッケージへの変換は2ステップで行う。</p>

<section>
<h2>package.jsonの更新</h2>

<ul>
<li><code>&quot;private&quot;: true</code>の削除</li>
<li><code>name</code>フィールドの値へプリフィックスを追加</li>
</ul>

<p>プリフィックスはなんでも良いようだが、通常はnpmのユーザー名を使うと良いだろう。僕は<code>@hail2u/</code>にしておいた。GitHubオーガニゼーション単位でスコープ化したい場合はその名前の方が良い。</p>
</section>

<section>
<h2>公開</h2>

<p>npmレジストリーへの公開にはオプションを追加する必要がある。特にインストールへ制限は設けないのなら<code>public</code>で良い。</p>

<pre><samp>$ <kbd>npm publish <mark>--access public</mark></kbd>
</samp></pre>

<p>このオプションの指定は最初に<code>npm publish</code>する時だけ必要になるようだ。</p>
</section>

<hr>

<p>特にnpmパッケージ自体を非公開にしたいわけではないけれど、プライベートにすることはたまにある。それほど本気でずっと使う予定もないとか、npmレジストリーの名前を占拠したくないとか、その場合にも変な名前を付けるのも嫌だとか、環境に強く依存していて自分専用に近いものとか。</p>

<p>こういった半プライベートなnpmパッケージをGitHub経由でインストールする(してもらう)というアプローチは、短期的にはあまり問題ない。しかしインストールはやはり遅く、特にCI環境下では致命的といえる。また、バージョン指定が特殊で面倒な感じになりやすい。そのため常に最新版を使うような運用にしてしまいがちで、あっと思ったら環境が壊れたということになりうる(やった)。</p>

<p>スコープ化しておくと通常のnpmパッケージとほとんど変わらず扱える。運用も同じように行うことになるので、GitHub経由特有の問題からは解放され、npmレジストリーとnpmパッケージそのものの問題に集約されることになる。問題が減るわけではないが、少なくとも問題の原因は減るので、その究明は楽になるだろう。</p>]]></content:encoded>
    </item>

  </channel>
</rss>
