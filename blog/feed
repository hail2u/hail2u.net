<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
  xml:lang="ja"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:creativeCommons="http://backend.userland.com/creativeCommonsRssModule"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Weblog - Hail2u.net</title>
    <link>http://hail2u.net/blog/</link>
    <description>ウェブ制作やウェブ標準の話題が中心ですが、それに限らず備忘録や日々の記録までを含めることで、10年以上続けることができたウェブログです。Blosxomを使って作られています。</description>
    <language>ja</language>
    <managingEditor>hail2u@gmail.com (Kyo Nagashima)</managingEditor>
    <lastBuildDate>Wed, 2 Sep 2015 05:38:23 +0900</lastBuildDate>
    <generator>blosxom v2.1.2+dev</generator>
    <atom:link rel="self" href="http://hail2u.net/blog/feed"/>
    <atom:link rel="hub" href="https://pubsubhubbub.appspot.com/"/>
    <creativeCommons:license>http://creativecommons.org/licenses/by-nc/3.0/</creativeCommons:license>


    <item>
      <title>Uptime RobotからiOSの通知へ</title>
      <link>http://hail2u.net/blog/internet/uptime-robot-to-ios-notification.html</link>
      <description>Uptime Robotはウェブサイトが落ちた時に通知してくれるが、その通知方法は限られている。スマホ・アプリがあって通知で受け取れることができれば良さそうだが、残念ながら公式アプリはない。そこで対応しているWebhookとIFTTTのMakerチャンネルを使うことでiOSの通知に送ることにした。</description>
      <category>Internet</category>
      <guid isPermaLink="true">http://hail2u.net/blog/internet/uptime-robot-to-ios-notification.html</guid>
      <pubDate>Wed, 02 Sep 2015 05:38:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p ><a href="https://uptimerobot.com/">Uptime Robot</a>はウェブサイトが落ちた時に通知してくれるが、その通知方法は限られている。スマホ・アプリがあって通知で受け取れることができれば良さそうだが、残念ながら公式アプリはない。そこで対応しているWebhookと<a href="https://ifttt.com/maker">IFTTTのMakerチャンネル</a>を使うことでiOSの通知に送ることにした。</p>

<p>IFTTT側でMakerチャンネルの設定が終わってるとすると、まずはUptime Robot側でMy SettingsからAlert Contactを追加する。</p>

<figure>
<table>
<thead>
<tr>
<th>設定</th>
<th>値</th>
</tr>
</thead>
<tbody>
<tr>
<td>Friendly Name</td>
<td>IFTTT Maker</td>
</tr>
<tr>
<td>URL to Notify</td>
<td>https://maker.ifttt.com/trigger/uptimerobot/with/key/{secret_key}?</td>
</tr>
<tr>
<td>JSON</td>
<td>{&quot;value1&quot;:&quot;<mark>monitorFriendlyName</mark>&quot;,&quot;value2&quot;:&quot;<mark>alertDetails</mark>&quot;}</td>
</tr>
</tbody>
</table>
<figcaption>Alert Contact Information</figcaption>
</figure>

<p>URLではイベントとして<code>uptimerobot</code>などを指定しておく(落ちた時と復活した時の両方で送られると思うので、<code>website_down</code>とかは付けないほうが良い)。また最後に<code>?</code>をつける必要がありそう。Makerチャンネルには3つまでしか値を渡せないので、モニターの名前(<code>monitorFriendlyName</code>)とエラーの詳細(<code>alertDetails</code>)が確定だろう。後で修正することはできないので、間違えた場合は消して作りなおす必要がある。</p>

<p>作り終わったら忘れずに各モニターの設定から通知先でIFTTT Makerにチェックを入れておく。</p>

<p>IFTTTレシピはトリガーがMakerチャンネルでアクションがIF Notificationsチャンネル（最近iOSとAndroidの通知チャンネルが統合された）になる。Makerチャンネル側では先ほどAlert ContactのURLで指定したイベント名<code>uptimerobot</code>を指定するだけだ。IF Notificationチャンネルの設定は以下のような簡単なものしか作ることはできなそうだ。IFアプリ経由での通知なので、Uptime Robotからの通知であることがすぐわかるようにラベルは付けておいた方が良い。</p>

<figure>
<table>
<thead>
<tr>
<th>フィールド</th>
<th>値</th>
</tr>
</thead>
<tbody>
<tr>
<td>Notification</td>
<td>Uptime Robot: {{Value1}} ({{Value2}})</td>
</tr>
</tbody>
</table>
<figcaption>Action: Send a notification</figcaption>
</figure>

<p>これでウェブサイトが落ちた場合にiPhone等へ次のような通知が送られてくる。</p>

<blockquote>
<p>Uptime Robot: Hail2u.net (HTTP 409 - Conflict)</p>
</blockquote>

<p>もちろん回復した時にもちゃんと通知が送られる。</p>

<blockquote>
<p>Uptime Robot: Hail2u.net (HTTP 200 - OK)</p>
</blockquote>

<p>GitHub Pagesが落ちた時やCloudFlareが調子悪い時にちゃんと通知が来るところまでは確認した。</p>]]></content:encoded>
    </item>

    <item>
      <title>夢</title>
      <link>http://hail2u.net/blog/misc/dreaming-20150827.html</link>
      <description>天の声に「CSSの基本は発声から」と言われる。朝起きたらまず裏の神社にお参りし、今日も一日CSSをうまく書けるように大きな声でお祈りすることが義務付けられる。恥ずかしいのでサボったらテキスト・エディターでCSSファイルが開けなくなった。基本大事だなーと思ったところで目が覚める。</description>
      <category>Misc.</category>
      <guid isPermaLink="true">http://hail2u.net/blog/misc/dreaming-20150827.html</guid>
      <pubDate>Mon, 31 Aug 2015 01:18:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p >天の声に「CSSの基本は発声から」と言われる。朝起きたらまず裏の神社にお参りし、今日も一日CSSをうまく書けるように大きな声でお祈りすることが義務付けられる。恥ずかしいのでサボったらテキスト・エディターでCSSファイルが開けなくなった。基本大事だなーと思ったところで目が覚める。</p>

<p>少し前にCSSかるたみたいな夢も見た。読む人が「display」って読むと、並べてある<code>block</code>や<code>inline</code>などを取れる。取れる札が複数あるかるた、ゲームとして成立しないことがわかった。</p>]]></content:encoded>
    </item>

    <item>
      <title>物の価値</title>
      <link>http://hail2u.net/blog/misc/the-value-of-things.html</link>
      <description></description>
      <category>Misc.</category>
      <guid isPermaLink="true">http://hail2u.net/blog/misc/the-value-of-things.html</guid>
      <pubDate>Thu, 27 Aug 2015 09:57:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p ><a href="http://hail2u.net/images/blog/23-year-old-t-shirts.jpg"><img alt="23年モノのTシャツ" height="2360" src="http://hail2u.net/images/blog/23-year-old-t-shirts.jpg" width="2360" ></a></p>

<p>遺品の整理をやっているわけだが、親(や多分配偶者)のものにはまったく価値が見いだせなくて、捨てるしかどうしようもない感じだ。思い出が多少あるものがあっても、明らかに着ることのできない洋服だったりする。袖が足らなかったり、ウエストが10cmくらい余ったり。</p>

<p>サイズが問題にならない鞄類は取っておいても良さそうだったが、あまりきれい好きではなかったため、酒のシミや匂いで厳しかった。唯一、一澤帆布のトートバッグは大丈夫そうだったので洗濯して使うことにした。あとはスーツケースか。服もカシミアのニットだけは貰って着ようと思う。</p>

<hr>

<p>多くの場合物の金銭的な価値は買った時点で失われ、利用価値と利用に伴う思い入れだけになる。最初の画像は僕が高校生の頃に買ったTシャツでなんだかんだで23年着ている。購入当時既に古着だったので、最低でも30年物くらいだと思う。だからといっても特に価値があるわけではなく、着やすいわけでもない。色は悪くないけれど、悪くはない程度だ。穴でもできない限りは捨てることなく毎夏着ることだろう。でも僕が死んだら間違いなく捨てられる。</p>

<p>いつ死んでも良いように身の回りのものを極限まで減らすのは馬鹿げていると思うけれど、明らかに遺族に負担がかかりそうなものは出来うる限り整理しておくくらいの気は使っても良いのかもしれない。服とかは捨てるのがまぁまぁ大変(そもそもまとめるのが大変であるとか、うちの自治体では雨降ってると出せないとかある)なので、着ないものはなるべく整理しておいた方が良さそうだ。</p>

<p>趣味のものについてはどうしようもないので、その整理に余力を残してやるためにも……という意味もある。生前にどうにかしろとか言うとケンカどころか警察沙汰になりかねないのでやめた方が良い。ようやく5万枚のデジタル写真の処理が終わって、あとは50PくらいあるB5サイズのアルバム30冊とスライド化されている3万枚くらいのネガの処理に移る。</p>

<hr>

<p>葬式直後くらいから何回か「不要な服や靴を無料で回収いたします」という主旨の電話が頻繁にかかってくるようになった。葬儀屋か火葬場、市役所あたりから伝わる謎のネットワークがあるのだろうか。</p>]]></content:encoded>
    </item>

    <item>
      <title>喪</title>
      <link>http://hail2u.net/blog/misc/mourning.html</link>
      <description>ゲーム期じゃなかった。父親が死んだので色々やったりしてた。あぁ誕生日だ。ひどい言い方になるが70を超えた辺りでそろそろとか考えたことはあったような気はするけど、僕が40になる前に死ぬとも思ってなかったし、こう突然死ぬとは思ってなかった。</description>
      <category>Misc.</category>
      <guid isPermaLink="true">http://hail2u.net/blog/misc/mourning.html</guid>
      <pubDate>Thu, 23 Jul 2015 00:12:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p >ゲーム期じゃなかった。父親が死んだので色々やったりしてた。あぁ誕生日だ。ひどい言い方になるが70を超えた辺りでそろそろとか考えたことはあったような気はするけど、僕が40になる前に死ぬとも思ってなかったし、こう突然死ぬとは思ってなかった。</p>

<p>漠然とガンでしばらく闘病してから死ぬとか、痴呆症になって徘徊老人となって公共放送で探したりする羽目になって介護施設に入りそこで死ぬとかそういうことは考えていた。でも実際にはそういう形ではなく、よくわからない形で倒れ、そのまま意識を回復することなく死んでしまった。70を超えるまで特に大病をすることもなく普通に生きていたように見えたので、それなりに死が見え隠れするような状況になって、徐々に死ぬようなことは考えていたような気がする。老々介護とかそういうのだ。</p>

<p>思ったのは普通にあっさりと死ぬのはなかなか難しいのかなということだ。普通に生活している中で「死んだ、あっはい」みたいにはいかない。何か重い病気になった場合でも長い闘病生活(看病生活)の後に死ぬことになるだろうし、痴呆症になった場合はもっと色々あった末に死ぬ。どちらもあっさりからはほど遠い。倒れて死んだらあっさりだろと思う人は多いけど、時間的には確かに短いが、その密度はかなりのものだった。</p>

<p>倒れて病院に運ばれてからどうなるかまったくわからないままただひたすら待つ。父親の場合はかなりひどい状態でまず1日は持たないだろうという話だったが、場合によっては意識がないまま数日どころかもっとということもありうる。その間、何もできることはない。ただ奇跡が起こるか死ぬかを待つだけだ。</p>

<p>死んでもそれで終わりというわけではなかった。死因がはっきりと特定できない場合、遺体は検視に回される。そして警察署で検視の完了をひたすら待つことになった。1日はかからなかったが、ほぼ18時間ほど警察官から事件性のあるなしを確定するために質問されつつただ待った。そして死亡時の担当医の都合に合わせて、翌日死体検案書を受け取ってようやく死後の作業に入ることができた。</p>

<p>交通事故など犯罪性のある事故ではもっと大変なのだろうということを考えると、普通にあっさりと死ぬことは難しい。というかほとんど無理そうだ。</p>

<hr>

<p>今思うのは平均寿命とか健康寿命とか徘徊老人とか老々介護とか特別養護老人ホームといった話題がただただ腹ただしい。もちろん八つ当たりなのだけど。70過ぎるまで大病もせずに生きていれば平均寿命を超えて生きるものだとまんまとミスリードされていたことが腹ただしいのか、それでも生きているだけ幸せなんじゃないかみたいな腹ただしさなのか。よくわからない。</p>

<hr>

<p>実は人が死んだ瞬間というのに立ち会ったのは生まれてはじめてかもしれない。それまで眠っていたような感じだった父親が突然顔色が悪くなり始めた後、少し痙攣し、寝ているのとはまったく違う感じになった。その時はこの瞬間を忘れることはできないと思っていたけど、1ヶ月も経たないうちにうまく思い出せなくなってきた。想像していた以上にショックは大きかったようだ。</p>

<p>こういうことも遺品を整理している中で、もう少し変わってくるのかもしれない。遺品整理の最大の壁は1冊辺り1000枚以上はあるスライド化されたネガ(白い厚紙とかに1枚ずつ挟まれたやつ)のファイルっぽい。50冊以上ある。本もものすごい数あるけれど、これはそのうち読もうと思っている。手始めに読んだことのなかった新共同訳聖書を読んでいる。ハードカバーですごい重い。</p>

<p>このすっきりしない感じもそのうち変わってくるのだろうか。たまに来る父親宛ての郵便物にまだ軽いショックを受けたりもする。</p>]]></content:encoded>
    </item>

    <item>
      <title>dns-prefetchとpreconnect、そしてprefetchやprerenderとpreloadの併記</title>
      <link>http://hail2u.net/blog/webdesign/dns-prefetch-preconnect-prefetch-prerender-preload.html</link>
      <description>2014年10月より標準化作業が公開されたResource Hints仕様により、既存のrel=dns-prefetchとrel=prefetch、そしてrel=prerenderは置き換えられる可能性がある。この置き換えが起こる可能性は決して高くはなさそうなので、実装されているもののままでも構わないと思うが、link要素のrel属性は複数の値を取ることができるので、同時指定しても良い。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/dns-prefetch-preconnect-prefetch-prerender-preload.html</guid>
      <pubDate>Wed, 24 Jun 2015 09:14:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p >2014年10月より標準化作業が公開された<a href="http://www.w3.org/TR/resource-hints/">Resource Hints仕様</a>により、既存の<code>rel=dns-prefetch</code>と<code>rel=prefetch</code>、そして<code>rel=prerender</code>は置き換えられる可能性がある。この置き換えが起こる可能性は決して高くはなさそうなので、実装されているもののままでも構わないと思うが、<code>link</code>要素の<code>rel</code>属性は複数の値を取ることができるので、同時指定しても良い。</p>

<p><code>rel=dns-prefetch</code>は<code>rel=preconnect</code>と完全に対応しているので、そのまま追加してやるだけになる。</p>

<pre><code >&lt;link
  href=&quot;//example.com&quot;
  rel=&quot;preconnect dns-prefetch&quot;&gt;
</code></pre>

<p><code>rel=prefetch</code>と<code>rel=prerender</code>はResource Hints仕様では<code>rel=preload</code>に統合される。事前にレンダリングまでするかどうかは<code>loadpolicy</code>属性を併用することで制御する。</p>

<pre><code >&lt;link
  href=&quot;http://example.com/fetch&quot;
  loadpolicy=&quot;next <mark>inert</mark>&quot;
  rel=&quot;preload prefetch&quot;&gt;
&lt;link
  href=&quot;http://example.com/render&quot;
  loadpolicy=&quot;next&quot;
  rel=&quot;preload prerender&quot;&gt;
</code></pre>

<p><code>rel=preload</code>はデフォルトで事前レンダリングを行うように支持するということになっており、それを無効にするためには<code>loadpolicy</code>属性で不活性やサボるなどという意味を持つ<code>inert</code>を指定する。つまり<code>rel=prefetch</code>と同じ挙動にしたい場合は<code>inert</code>を追加するということになる。</p>

<p><code>rel=preload</code>では他に<code>pr</code>属性を使って<del>読み込みのプライオリティー</del>を、<code>as</code>属性を使って読み込むリソースの形式を指定することもできるようになっている。<del>特にウェブアプリではその動線の予測しやすさから、事前読み込みを駆使することになると思うので、<code>pr</code>属性を使ってうまくプライオリティーを制御することでより効果的なプリロードを行えることだろう。</del>対して<code>as</code>属性での形式の指定は、画像やフォントの場合は択一式で提供することも多いはずなので、<code>html</code>以外を使う機会はあまりなさそうだ。</p>

<hr>

<p>あとは実際にうまく機能してくれるかどうかということになる。</p>

<aside >
<p>Chrome 43では開発者ツールのネットワークで<code>rel=dns-prefetch</code>や<code>rel=prefetch</code>の動作を確認でき、タスク マネージャ(Chromeのそれ)でレンダリング・プロセスが走っていることにより<code>rel=prerender</code>の動作を確認できる。</p>
</aside>

<p><code>rel=dns-prefetch</code>と<code>rel=preconnect</code>の併記は、Firefox 38及びChrome 43、Internet Explorer 11でちゃんと名前解決を行っているらしいことが確認できた。</p>

<p><code>rel=prefetch</code>と<code>rel=prerender</code>の両方に対応しているChrome 43とInternet Explorer 11ではどちらの併記方法もうまく動いているらしきことは確認できた。Firefox 38でも<code>rel=prefetch</code>の方の併記は問題ないようだった。</p>

<hr>

<p>速やかに<code>rel=preconnect</code>と<code>rel=preload</code>へと移行されるかというと大きく疑問が残る。Resource Hints仕様が現状の実装に比べて大きく強化されていることもそうだが、実装の足並みがバラバラで各自が制限や拡張を行っていることや、プリフェッチ系の機能への根強い抵抗があることもある。少なくともマルチ・プロセス化したFirefoxが<code>rel=prerender</code>相当の機能を実装するくらいになるまではどうなるかの予想は難しいだろう。</p>

<p>ともあれ現時点では併記しておくというのは悪くない。運良くResource Hints仕様へ揃う可能性もなくはないからだ。</p>]]></content:encoded>
    </item>

    <item>
      <title>Postcards from Penguin</title>
      <link>http://hail2u.net/blog/gadget/postcards-from-penguin.html</link>
      <description>ペンギン・ブックスの本のカバーをポストカードにしたものの100枚入りのセット、Postcards from Pengin: One Hundred Book Covers in One Boxを衝動買いした。Amazon.co.jpでタイポグラフィーの本を漁ってたら見つけた。100枚入っていてもだいたいは同じデザイン……なんだけれどもそこが異様に良い。2500円くらいだった。</description>
      <category>Gadget</category>
      <guid isPermaLink="true">http://hail2u.net/blog/gadget/postcards-from-penguin.html</guid>
      <pubDate>Tue, 23 Jun 2015 00:37:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure >
  <a href="http://www.amazon.co.jp/gp/product/0141044667/ref=as_li_ss_il?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=0141044667&amp;linkCode=as2&amp;tag=hail2unet-22"><img alt="Postcards from Penguin: One Hundred Book Covers in One Box" src="http://ecx.images-amazon.com/images/I/410OK-ej6sL.jpg" ></a>
</figure>

<p >ペンギン・ブックスの本のカバーをポストカードにしたものの100枚入りのセット、<a href="http://www.amazon.co.jp/gp/product/0141044667/ref=as_li_ss_il?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=0141044667&amp;linkCode=as2&amp;tag=hail2unet-22">Postcards from Pengin: One Hundred Book Covers in One Box</a>を衝動買いした。Amazon.co.jpでタイポグラフィーの本を漁ってたら見つけた。100枚入っていてもだいたいは同じデザイン……なんだけれどもそこが異様に良い。2500円くらいだった。</p>

<p><a href="https://instagram.com/p/4LPx-iqG1C/">ハードカバーの本のようなボックス</a>に入っている。背表紙のペンギンは安定の可愛さ。それほど高級感はないが、ボックスの表面はきちんとコーティングされていて、そう簡単にはヘタレなさそう。手触りも良い。</p>

<p>レビューをあさってたら50種類の2枚づつみたいな話もみつけたけれど、ちゃんと100種類ある(と思う)。ペンギンはいつも直立不動っていう訳じゃないとか、ちょっとの違いが楽しい。ペリカン・ブックスのものも結構な割合で混ざっていて、こちらは科学的な教養書が中心なので、ちょっとレトロ・フューチャーっぽい雰囲気がありこれもまた楽しい。</p>

<figure >
  <a href="http://hail2u.net/images/blog/postcards-from-penguin.jpg"><img alt="華麗なるギャツビーや嵐が丘、オデュッセイア、ペリカン・ブックスの教本などのレトロなカバーをポストカードにしたもの" height="1530" src="http://hail2u.net/images/blog/postcards-from-penguin.jpg" width="2720"></a>
  <figcaption>Postcards from Penguin</figcaption>
</figure>

<p>ばら撒いてるだけでも楽しくなってくる。額にうまく並べて飾れたら、下手なポスターよりもかっこよくなりそうだ。けど1枚25円もしないくらいなので、額の方が高くつく。切手を傷つけずに貼る時に使うヒンジとかをうまく使って工夫した方が良さそう。</p>

<hr>

<p>ポストカード集めの趣味をすごいバカにしていたけど、ハマりそうな感じがする。あまり手間と暇と金をかけずに収集感が得られて楽しい。</p>]]></content:encoded>
    </item>

    <item>
      <title>プリフェッチ中のリクエスト</title>
      <link>http://hail2u.net/blog/webdesign/fetching-when-prefetching.html</link>
      <description>特定のリソースをrel=prefetchを使ってプリフェッチしている最中に、何らかの形で新たにリクエストされるような状況になった場合、各ブラウザーはどういう挙動になるのかということを試していた。Firefox 38ではプリフェッチがそのまま続行され、新たなリクエストは発生しないという賢い挙動のようだ。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/fetching-when-prefetching.html</guid>
      <pubDate>Mon, 22 Jun 2015 09:42:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p >特定のリソースを<code>rel=prefetch</code>を使ってプリフェッチしている最中に、何らかの形で新たにリクエストされるような状況になった場合、各ブラウザーはどういう挙動になるのかということを試していた。Firefox 38ではプリフェッチがそのまま続行され、新たなリクエストは発生しないという賢い挙動のようだ。</p>

<p >View Demo: <a href="http://hail2u.net/pub/test/637.html">Fetching when Prefetching</a></p>

<p>デモでは<code>rel=prefetch</code>を使って<code>head</code>要素内で画像を先読みさせ、ドキュメントの読み込み完了の1秒後に動的に突っ込んだ<code>img</code>要素によりリクエストしてやろうとしている。開発者ツールなどでネットワーク状況を確認することで、どういう挙動になるか確認できる。</p>

<p>Firefox 38ではプリフェッチがそのまま続行され、新たにリクエストを発生せずに画像が挿入される。対してChrome 43とInternet Explorer 11ではプリフェッチがそのまま続行された上で、<code>img</code>要素を追加した時にもリクエストが走るようになり、プリフェッチは完全に無駄になる。</p>

<hr>

<p>主に同じページで使われるリソースを想定した<a href="https://www.chromium.org/spdy/link-headers-and-server-hint/link-rel-subresource"><code>rel=subresource</code>という別のヒント</a>が考えられていることや、より正確に制御することが可能になる<a href="http://www.w3.org/TR/resource-hints/">Resource Hints仕様(これでは<code>rel=preload</code>になる)</a>が作られていることを踏まえると、<code>rel=prefetch</code>他は現状の実装のままで、仕様に従った実装が新たに追加されそうだ。少なくとも<code>rel=prefetch</code>がFirefox 38の挙動に揃うことはなさそうだ。</p>]]></content:encoded>
    </item>

    <item>
      <title>WebhookからPubSubHubbubへの翻訳</title>
      <link>http://hail2u.net/blog/rss/webhook-to-pubsubhubbub.html</link>
      <description>少し前に公開されたIFTTTのMakerチャンネルを使って、GitHubリポジトリーのWebhookをPubSubHubbubの公開POSTリクエストに翻訳するようにした。GETを使った公開リクエストがあまり行儀が良くなさそうなことが前から気になっていたので、Makerチャンネルを使えば良いかなと試したところうまくいった。</description>
      <category>RSS</category>
      <guid isPermaLink="true">http://hail2u.net/blog/rss/webhook-to-pubsubhubbub.html</guid>
      <pubDate>Sun, 21 Jun 2015 07:13:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p >少し前に公開された<a href="https://ifttt.com/">IFTTT</a>の<a href="https://ifttt.com/maker">Makerチャンネル</a>を使って、GitHubリポジトリーのWebhookをPubSubHubbubの公開POSTリクエストに翻訳するようにした。<a href="http://hail2u.net/blog/internet/publishing-feed-via-pubsubhubbbub-using-github-webhooks.html">GETを使った公開リクエスト</a>があまり行儀が良くなさそうなことが前から気になっていたので、Makerチャンネルを使えば良いかなと試したところうまくいった。</p>

<section>
<h2>Makerチャンネルの有効化</h2>

<p>まずはMakerチャンネルのページへ行き、Connectボタンを押す。するとユーザーごとに専用のエンドポイントURLが作成されるので、How to Trigger Eventsというリンクをクリックして、それを確認しておく。</p>

<pre>https://maker.ifttt.com/trigger/{event}/with/key/{secret_key}
</pre>

<p>エンドポイントURLはこのような形になっている。<code>{event}</code>は後ほど好きに指定することになる。<code>{secret key}</code>はユーザーごとに発行されるユニークな文字列に置き換えられて表示される。第三者にバレるとまずそうなので、気を付けた方が良い(再生成することは可能)。</p>
</section>

<section>
<h2>GitHub Pages側の準備</h2>

<p>各リポジトリーの設定からWebhooks &amp; Servicesのページにアクセスし、Add Webhookボタンを押す。Payload URLにIFTTTのMakerチャンネルで作成された専用のエンドポイントURLを指定する。ここではGitHub PagesがビルドされたらPubSubHubbubで公開したいので、<code>{event}</code>は<code>page_build</code>にしておいた。GitHubリポジトリー側のイベントに対応させた名前にすると良いだろう。データを受け取ってゴニョゴニョするわけではないのでContent typeはどちらでも良いが、Secretは指定する必要がある(と思う)。</p>

<p>イベントはPage builtのみに絞っておくと良いだろう。</p>
</section>

<section>
<h2>レシピの作成</h2>

<p>Trigger側では先ほどGitHubリポジトリー側で指定したエンドポイントURLで使ったイベント名を指定する(ここでは<code>page_build</code>)。Action側では、以下のように指定すれば良い。</p>

<figure>
<table>
<thead>
<tr>
<th>フィールド</th>
<th>値</th>
</tr>
</thead>
<tbody>
<tr>
<td>URL</td>
<td>https://pubsubhubbub.appspot.com/</td>
</tr>
<tr>
<td>Method</td>
<td>POST</td>
</tr>
<tr>
<td>Content Type</td>
<td>application/x-www-form-urlencoded</td>
</tr>
<tr>
<td>Body</td>
<td>hub.mode=publish&amp;hub.url=http:%2F%2Fexample.com%2Ffeed</td>
</tr>
</tbody>
</table>
<figcaption>Action: Make a web request</figcaption>
</figure>

<p>Bodyフィールドで指定するRSSフィードのURL以外は同じで良いはずだ。Bodyフィールドでは自前でURLエンコードして指定しているが<code>&lt;&lt;&lt;</code>と<code>&gt;&gt;&gt;</code>で生URLを括るときっとURLエンコードされるだろう。</p>
</section>

<hr>

<p>これでGitHubリポジトリーの<code>gh-pages</code>ブランチへpushしGitHub Pagesのビルドを走らせると、一連の動作が確認できる。</p>

<p>GitHubリポジトリー側では、該当Webhookの管理画面にRecent Deliveriesというログが残っているので、そこでIFTTT側から<code>200</code>が帰っていることを確認することでリクエストが成功していることを確認できる。IFTTTのレシピ側では、Personal Recipe triggeredというログで、レシピが走りPubSubHubbubハブへのリクエストが成功していることを確認できる。更にGoogleのPubSubHubbubハブに用意されている<a href="https://pubsubhubbub.appspot.com/publish">Publisher Diagnostics</a>を使ってRSSフィードのURLを調べると、最後に記事を受け取った時刻と内容がわかるので、それを照らし合わせることで公開がうまくいっているか確認できる。</p>

<p>気になる人はFeedlyなどPubSubHubbubによる購読に対応しているフィード・リーダーを使うと公開即反映されているかも確認することができる。</p>

<hr>

<p>某アプリのおかげでRSSフィードが本来想定されていたような機械的に処理することのできるフォーマットのコンテンツとして復権する可能性がある。それと同時にポーリングではないPubSubHubbubによる公開と購読の重要性も上がるのではないかと考えられる。折に触れPubSubHubbubに言及することにより、少しでもPubSubHubbubによる公開を行ってくれるウェブログ(とウェブログ・ホスティング・サービス)が増えることに期待したい。</p>]]></content:encoded>
    </item>

    <item>
      <title>夢</title>
      <link>http://hail2u.net/blog/misc/dreaming-20150620.html</link>
      <description>湯船で丸々一本漏らす。あわてて手桶ですくい、トイレに流そうと風呂から出たらおばあちゃん(故人)に見つかる。そのまま正座させられ説教をされる。おばあちゃんには怒られたことがなかったので、すごいショックを受けつつ、とにかく服を着たかった。途中で「体拭いて服着ていい？」って聞いたら、「良いよ」ってニッコリ笑って返事してくれて、そのまますうっと蒸発するみたいに消えた。</description>
      <category>Misc.</category>
      <guid isPermaLink="true">http://hail2u.net/blog/misc/dreaming-20150620.html</guid>
      <pubDate>Sat, 20 Jun 2015 06:24:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p >湯船で丸々一本漏らす。あわてて手桶ですくい、トイレに流そうと風呂から出たらおばあちゃん(故人)に見つかる。そのまま正座させられ説教をされる。おばあちゃんには怒られたことがなかったので、すごいショックを受けつつ、とにかく服を着たかった。途中で「体拭いて服着ていい？」って聞いたら、「良いよ」ってニッコリ笑って返事してくれて、そのまますうっと蒸発するみたいに消えた。</p>

<p>なお現実世界では漏らしていなかった。</p>]]></content:encoded>
    </item>

    <item>
      <title>レイ → ← アウト</title>
      <link>http://hail2u.net/blog/webdesign/layout-changes-20150618.html</link>
      <description>ロゴの形状を変えたら広い画面のマルチカラムではずいぶんとバランスが悪くなった。そうでもないと思っていたけれど日に日に気になり度が増してきたため、レイアウトの基本を少し変更することにした。広い画面ではロゴを含めてコンテンツはメインカラムの左寄せに、サブカラムの中身は右寄せにするようにし、両者が詰まりすぎないようにその間を少し広くしてバランスをとった。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/layout-changes-20150618.html</guid>
      <pubDate>Fri, 19 Jun 2015 08:23:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p >ロゴの形状を変えたら広い画面のマルチカラムではずいぶんとバランスが悪くなった。そうでもないと思っていたけれど日に日に気になり度が増してきたため、レイアウトの基本を少し変更することにした。広い画面ではロゴを含めてコンテンツはメインカラムの左寄せに、サブカラムの中身は右寄せにするようにし、両者が詰まりすぎないようにその間を少し広くしてバランスをとった。</p>

<p>本当はカラムの間の中央にロゴを置きたいのだけど、グローバル・ナビゲーションの位置が難しい。そのまま右端だとヘッダーのバランスは良いものの、他のコンテンツとの一貫性に欠ける。左に浮かせた場合はロゴが左による分、ヘッダーだけずれているような印象になる。</p>

<p>グローバル・ナビゲーションを左右に分割してやるのが良さそうかなと調節しているところだ。これだとバランスは取れるが、CSSが異様に複雑になる。ロゴを浮かせて、グローバル・ナビゲーションをメインカラムに置いた方が良いのかもしれない。</p>]]></content:encoded>
    </item>

  </channel>
</rss>
