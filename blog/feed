<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
  xml:lang="ja"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:creativeCommons="http://backend.userland.com/creativeCommonsRssModule"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Weblog - Hail2u.net</title>
    <link>http://hail2u.net/blog/</link>
    <description>ウェブ制作やウェブ標準の話題が中心ですが、それに限らず備忘録や日々の記録までを含めることで、10年以上続けることができたウェブログです。Blosxomを使って作られています。</description>
    <language>ja</language>
    <managingEditor>hail2u@gmail.com (Kyo Nagashima)</managingEditor>
    <lastBuildDate>Thu, 18 Jun 2015 09:43:11 +0900</lastBuildDate>
    <generator>blosxom v2.1.2+dev</generator>
    <atom:link rel="self" href="http://hail2u.net/blog/feed"/>
    <atom:link rel="hub" href="https://pubsubhubbub.appspot.com/"/>
    <creativeCommons:license>http://creativecommons.org/licenses/by-nc/3.0/</creativeCommons:license>


    <item>
      <title>外国語の読み方</title>
      <link>http://hail2u.net/blog/misc/foreign-words-pronunciation.html</link>
      <description>外国語の読み方はしゃべる人の立場としゃべる相手の想定によって変わってくる。大雑把に有識者やエバンジェリストなどと呼ばれる立場の人達は、なるべく誤解を広めないようにすることを重視して、正確に引き写した音で読んだ方が良い。一方、知識の拡散と質の向上を狙うわけではない人達は、同じような専門家に向けてしゃべるわけではないことも考え、まずは通じることを重要視して雑に読んでも良いはずだ。</description>
      <category>Misc.</category>
      <guid isPermaLink="true">http://hail2u.net/blog/misc/foreign-words-pronunciation.html</guid>
      <pubDate>Thu, 18 Jun 2015 09:43:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p >外国語の読み方はしゃべる人の立場としゃべる相手の想定によって変わってくる。大雑把に有識者やエバンジェリストなどと呼ばれる立場の人達は、なるべく誤解を広めないようにすることを重視して、正確に引き写した音で読んだ方が良い。一方、知識の拡散と質の向上を狙うわけではない人達は、同じような専門家に向けてしゃべるわけではないことも考え、まずは通じることを重要視して雑に読んでも良いはずだ。</p>

<p>少なからず両方を担うことがある人達の発音がブレるのは仕方がない。僕もよくブレているし、人を見て恐る々々読み方を変えていたりする。重要視すべきものが立場と相手で変わってきてしまうからということが表の理由だ。広める側としてちゃんとしたいという見栄と、専門家ではない人達へネイティブに近い発音でしゃべった時に通じなかった場合のあの微妙な空気と間、このあたりが裏の理由だろうか。</p>

<p>場合によって読み分けると書こうとすると、この記事のようなふわっとした、ある種本質的ではない話になってしまう。そのためウェブではどうしてもとがった意見の記事ばかりになる。とにかく正確にしろという理想または通じれば良いという現実のどちらかに振り切った記事しか読んだ記憶がない。</p>

<hr>

<p>もののついでに<a href="https://gist.github.com/hail2u/e19d227da90e6393505e">僕がCSSプロパティーをどう読んでいるか</a>を表にした。</p>

<p><code>width</code>は紆余曲折の結果「ウィドス」に落ち着き、もうそれ以外で読めなくなっている。「ウィズ」くらいの感覚で読んでると「え？何？」とか「あっフフッ」みたいな反応をされることが多かった。「ウィドゥス」になるとちょっと凝った感じに聞こえるらしく、失笑される機会が極端に増えつらかった。「ウィドス」はだいたい通じるので便利だ。そろそろ「ヘイト」派に流されそうだ。</p>

<p>しかし世界も徐々に変わってきていて、耳慣れない読み方でも互いに察してくれるようになってきた。これは日本人特有の事なかれ主義の発現ではなくて、ネイティブっぽい発音を小馬鹿にするような因習が消え始めたのだろう。</p>]]></content:encoded>
    </item>

    <item>
      <title>ウェブデザインのトレンドとその背景</title>
      <link>http://hail2u.net/blog/webdesign/webdesign-trends-and-their-backgrounds.html</link>
      <description>7 future web design trendsという記事を読んでいた。これらは既に(または元々)未来のトレンドじゃないという点を見なかったことにしても、構図を単純化しすぎなきらいがあり、トレンドっぽいものの紹介とその正当化という記事としか読めなかった。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/webdesign-trends-and-their-backgrounds.html</guid>
      <pubDate>Wed, 17 Jun 2015 10:59:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p ><a href="https://medium.com/@jowitaziobro/7-future-web-design-trends-fba93eba6355">7 future web design trends</a>という記事を読んでいた。これらは既に(または元々)<em>未来</em>のトレンドじゃないという点を見なかったことにしても、構図を単純化しすぎなきらいがあり、トレンドっぽいものの紹介とその正当化という記事としか読めなかった。</p>

<p>スクロールが中心になったことは確かで、そのことに最適化して無限スクロールを採用する(元記事の1)のは間違っていない。ファーストビュー信仰が最初から間違っていたことも事実で、ヒーロー・イメージなどと呼ばれるフルスクリーンの画像や動画の採用(元記事の2)は妥当に思える。しかしこの両者を同じスクロールという行為に対するトレンドとまとめるのは雑すぎる。</p>

<p>前者はスクロールという行為そのものと回線速度に最適化しているものだ。無限スクロールの利点は単にスクロールのみでコンテンツを読み進めていくことができるだけではなく、効率的なコンテンツの読み込みをもたらすことができる。むしろ<em>モバイル</em>というコンテキストで考えると、この回線速度における利点の方が重要だと言えるだろう。</p>

<p>後者はスクロールという行為を最優先させるユーザーに最適化したものだ。ウェブページを開くと人はスクロールするということを念頭に置くと、画面全体を支配する画像は特にデメリットにはならず、美しい包装紙のようにブランディングに良い影響を与えることができるだろう。しかしこのトレンドはモバイルに最適化されたものではない。なぜならばそういった画面全体を支配する画像はサイズが大きくなりがちで、回線速度に劣ることの多いモバイル環境では負担が大きくなりがちだからだ。</p>

<p>この筆者の言うところのトレンド自体はそれなりに受け入れられるし、既にトレンドになったと言って良いものだ。しかし、このようにモバイル対デスクトップという単純な構図に落としこむのは間違っている。少なくともウェブサイト制作に関わる人々はこういったトレンドの背景をもう少し掘り下げてみるべきだろう。</p>]]></content:encoded>
    </item>

    <item>
      <title>Chromeとpre要素</title>
      <link>http://hail2u.net/blog/webdesign/pre-on-chrome.html</link>
      <description>しばらく前から特定のフォントをpre要素へ指定すると、Chromeのみでほとんど意味のない縦スクロールバーが表れるという現象に悩まされている。とは言ってもWindows以外ではもはやスクロールバーが見えることはないので、事実上WindowsのChromeユーザーのみが影響を受ける。DirectWriteが有効になったChrome 37あたりから頻発するようになった印象だ。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/pre-on-chrome.html</guid>
      <pubDate>Tue, 16 Jun 2015 10:01:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure >
  <a href="http://hail2u.net/images/blog/pre-on-chrome.png"><img alt="謎の縦スクロールバー" height="627" src="http://hail2u.net/images/blog/pre-on-chrome.png" width="1200" ></a>
</figure>

<p >しばらく前から特定のフォントを<code>pre</code>要素へ指定すると、Chromeのみでほとんど意味のない縦スクロールバーが表れるという現象に悩まされている。とは言ってもWindows以外ではもはやスクロールバーが見えることはないので、事実上WindowsのChromeユーザーのみが影響を受ける。DirectWriteが有効になったChrome 37あたりから頻発するようになった印象だ。</p>

<p>修正は簡単で、上下どちらかに<code>padding</code>プロパティーを追加してやれば良い。</p>

<pre><code >pre {
  padding-bottom: 1px;
}
</code></pre>

<p>実害はあまりないように書いてしまったけれど、Mobile SafariなどWebKit系でもさり気なく発生しているような気がする。発生しても見た目は問題ない(スクロールバーが見えないので)が、ちょうどそこでスワイプしてスクロールしようとするとうまくスクロールされなかったりする。</p>

<p>とにかく再現条件がまったくわからない。このウェブサイトでは発生しているので、上記CSSによってアドホックに解決している。</p>]]></content:encoded>
    </item>

    <item>
      <title>パッケージのスコープ化</title>
      <link>http://hail2u.net/blog/software/scoped-npm-packages.html</link>
      <description>2015/04/15よりnpmレジストリーでパッケージのスコープ化が行えるようになった。パッケージのスコープ化は名前の衝突を回避することが主な目的のような取り上げられ方だが。僕は今まで色々な理由でnpmレジストリーへは非公開にしてGitHub経由でインストールすることを推奨していたようなパターンで使うのが良さそうだという感想を持った。</description>
      <category>Software</category>
      <guid isPermaLink="true">http://hail2u.net/blog/software/scoped-npm-packages.html</guid>
      <pubDate>Mon, 15 Jun 2015 11:46:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p >2015/04/15よりnpmレジストリーでパッケージのスコープ化が行えるようになった。パッケージのスコープ化は名前の衝突を回避することが主な目的のような取り上げられ方だが。僕は今まで色々な理由でnpmレジストリーへは非公開にしてGitHub経由でインストールすることを推奨していたようなパターンで使うのが良さそうだという感想を持った。</p>

<p><code>&quot;private&quot;: true</code>からスコープ化したパッケージへの変換は2ステップで行う。</p>

<section>
<h2>package.jsonの更新</h2>

<ul>
<li><code>&quot;private&quot;: true</code>の削除</li>
<li><code>name</code>フィールドの値へプリフィックスを追加</li>
</ul>

<p>プリフィックスはなんでも良いようだが、通常はnpmのユーザー名を使うと良いだろう。僕は<code>@hail2u/</code>にしておいた。GitHubオーガニゼーション単位でスコープ化したい場合はその名前の方が良い。</p>
</section>

<section>
<h2>公開</h2>

<p>npmレジストリーへの公開にはオプションを追加する必要がある。特にインストールへ制限は設けないのなら<code>public</code>で良い。</p>

<pre><samp>$ <kbd>npm publish <mark>--access public</mark></kbd>
</samp></pre>

<p>このオプションの指定は最初に<code>npm publish</code>する時だけ必要になるようだ。</p>
</section>

<hr>

<p>特にnpmパッケージ自体を非公開にしたいわけではないけれど、プライベートにすることはたまにある。それほど本気でずっと使う予定もないとか、npmレジストリーの名前を占拠したくないとか、その場合にも変な名前を付けるのも嫌だとか、環境に強く依存していて自分専用に近いものとか。</p>

<p>こういった半プライベートなnpmパッケージをGitHub経由でインストールする(してもらう)というアプローチは、短期的にはあまり問題ない。しかしインストールはやはり遅く、特にCI環境下では致命的といえる。また、バージョン指定が特殊で面倒な感じになりやすい。そのため常に最新版を使うような運用にしてしまいがちで、あっと思ったら環境が壊れたということになりうる(やった)。</p>

<p>スコープ化しておくと通常のnpmパッケージとほとんど変わらず扱える。運用も同じように行うことになるので、GitHub経由特有の問題からは解放され、npmレジストリーとnpmパッケージそのものの問題に集約されることになる。問題が減るわけではないが、少なくとも問題の原因は減るので、その究明は楽になるだろう。</p>]]></content:encoded>
    </item>

    <item>
      <title>OGPとlink要素</title>
      <link>http://hail2u.net/blog/webdesign/ogp-and-link-element.html</link>
      <description>HTTPS化の準備を始めるにあたって、HTMLで内部的に利用しているURLを対応するのは簡単だ。すべて相対URLに書き換えるだけで対応することができる。その相対URLの書き換えもパスの位置を考慮して最短にする必要もなく、//で始まる相対URLで行えば良い。aやimg要素はもちろん、scriptやlink要素も相対URLで問題ない。しかし外部から利用されるURLもどきではこの限りではない。例えばOGPなど利用することになるmeta要素では相対URLは使えず、OGPの仕様そのものでmeta要素に限定されており、そのパーサー実装のひとつであるFacebookでも解釈できない(できなかった)。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/ogp-and-link-element.html</guid>
      <pubDate>Sun, 14 Jun 2015 07:18:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p >HTTPS化の準備を始めるにあたって、HTMLで内部的に利用しているURLを対応するのは簡単だ。すべて相対URLに書き換えるだけで対応することができる。その相対URLの書き換えもパスの位置を考慮して最短にする必要もなく、<code>//</code>で始まる相対URLで行えば良い。<code>a</code>や<code>img</code>要素はもちろん、<code>script</code>や<code>link</code>要素も相対URLで問題ない。しかし外部から利用されるURLもどきではこの限りではない。例えばOGPなど利用することになる<code>meta</code>要素では相対URLは使えず、OGPの仕様そのもので<code>meta</code>要素に限定されており、そのパーサー実装のひとつであるFacebookでも解釈できない(できなかった)。</p>

<p>OGPはRDFa Liteだが、なぜか<code>meta</code>要素で記述すると決められている。<code>meta</code>要素ではURLの解決が行われないので、URLスキームは省略できない(仮にFacebookが解釈できるようになっていたとしてもそう書くべきではないだろう)。もちろんCMSやそれに類するものを使っていれば書き換えは機械的に行うことは可能だが、そういう問題ではないだろうし、書き換えた時点でユーザーのキャッシュが破棄されることにもなる。</p>

<p>OGPと似ているもののRDFa LiteのモドキですらないTwitter Cardsでは<code>link</code>要素を使えたりもするが、相対URLへの対応は挙動が不審だった。少なくとも画像(<code>twitter:image</code>)についてはパーサー自体は通すものの表示には対応してくれないようだ。</p>

<p>URLの変更は気軽に行われるべきではないので、それだけを考えていれば良かった時代ではこういう仕様でもあまり問題はなかった。しかしHTTPS化の有形・無形の圧力と欲求にさらされることで、こういったウェブサービスの仕様がフレキシブルに対応できないものとなっている点が表面化してきてしまった。</p>

<hr>

<p>結局はこちら側からはどうにもできないので、やるしかない。手元ではCMSの設定でURLスキームの切り替えを簡単に行えるように対応させつつあり、ようやく準備は完了してきた。しかしよくわからない人達が勝手に作った標準っぽいオレオレ仕様を考慮して苦労するのは割に合わないし、すっきりしない。</p>]]></content:encoded>
    </item>

    <item>
      <title>2015ロ06ゴ12</title>
      <link>http://hail2u.net/blog/webdesign/logo-20150612.html</link>
      <description>ロゴを変えた。ベースはそのままに消印っぽい枠を付け、反時計回りに20度回転させている。ウェブページでは透過背景に青で、Facebook他で使う画像は青背景に薄いベージュした。faviconの方はそのままでは潰れてしまうので、16px四方と32px四方のバージョンのみ外側の枠を削除したものにしている。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/logo-20150612.html</guid>
      <pubDate>Sat, 13 Jun 2015 06:27:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure >
  <a href="http://hail2u.net/images/blog/logo-20150612.svg"><img alt="消印っぽいやつ" height="627" src="http://hail2u.net/images/blog/logo-20150612.svg" width="1200" ></a>
</figure>

<p >ロゴを変えた。ベースはそのままに消印っぽい枠を付け、反時計回りに20度回転させている。ウェブページでは透過背景に青で、Facebook他で使う画像は青背景に薄いベージュした。faviconの方はそのままでは潰れてしまうので、16px四方と32px四方のバージョンのみ外側の枠を削除したものにしている。</p>

<p>SVGはスケーラブルだけれども、縮小した場合にはどうしても細部が潰れてしまう。反対に拡大した時は大丈夫かというと、今度は余白を始めとした全体的な印象が変化してしまう。SVGで作れば単純に拡大・縮小するだけで済むというのは、一筆書きで書けるような単純な図形や幾何学的な図形の組み合わせの場合には正しい。または逆に細部の詳細さが無視できる程度に複雑なイラストの場合にも正しいと言っても良いだろう。</p>

<p>しかし、若干複雑で細部にそれなりに詳細さを要求するようなケースではそううまくはいかない。具体的に言うと社名やキャッチコピー付きのロゴなどがそうだ。最近の傾向としてはロゴを単純化することで、細部が潰れても問題ないようにすることが多い。サイズによって複数のデザインを使い分けるのはコストがかかるが、周囲のコンテンツとのバランスは取りやすい。単純化するのはイマドキではあるが、それだけが解ではないということだ。</p>]]></content:encoded>
    </item>

    <item>
      <title>オペラ座の怪人</title>
      <link>http://hail2u.net/blog/media/the-phantom-of-the-opera.html</link>
      <description>5年ぶりくらいに読みたくなったので本箱を漁っていたけどなかったので買った。前に読んだのは創元推理文庫版だったと思うので、今度は角川文庫版にした。確かにずいぶんと読みやすい気がする。文体の古さを噛み砕きながらまじめにゆっくりと読むのも好きだけど、読みやすいと連続で読む気になったりして、楽なのも悪くないなと最近は感じる。</description>
      <category>Media</category>
      <guid isPermaLink="true">http://hail2u.net/blog/media/the-phantom-of-the-opera.html</guid>
      <pubDate>Fri, 12 Jun 2015 07:39:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure >
  <a href="http://www.amazon.co.jp/gp/product/4042840019/ref=as_li_ss_il?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4042840019&amp;linkCode=as2&amp;tag=hail2unet-22"><img alt="オペラ座の怪人 (角川文庫)" src="http://ecx.images-amazon.com/images/I/41JQWRT9N9L.jpg" ></a>
</figure>

<p >5年ぶりくらいに読みたくなったので本箱を漁っていたけどなかったので買った。前に読んだのは創元推理文庫版だったと思うので、今度は角川文庫版にした。確かにずいぶんと読みやすい気がする。文体の古さを噛み砕きながらまじめにゆっくりと読むのも好きだけど、読みやすいと連続で読む気になったりして、楽なのも悪くないなと最近は感じる。</p>

<p>ここ10年くらいで一気にこれと同時代の文学が再翻訳されつつある。あれであれなあれの事情が解消されたからか。僕は和洋を問わずだいたいこの辺りの時代の文学が好きなため、若干古めかしく読みづらいとも言える古い文体での翻訳も好き。古さを意識しながら読めるからとか、現代を忘れられるからとか。ただ再翻訳では誤訳や何かの都合で省かれた部分が修正されたりするため、気になって欲しくなったりするのでずるい。</p>

<hr>

<p>やっぱり災厄の町の新訳版が欲しくなってきた。完全な電子書籍時代になると、もしかしたらこういった新訳も無料か安価に手に入れられたりするようになるのかな。</p>]]></content:encoded>
    </item>

    <item>
      <title>PostCSSプラグイン</title>
      <link>http://hail2u.net/blog/coding/postcss-plugin.html</link>
      <description>PostCSS v4.1.0からプラグインAPIが実装され、postcss.plugin()でプラグインを作ることが推奨されるようになった。このガイドラインに従って作ることで、プラグイン間で一貫性が保たれ、エラーもわかりやすくなるというわけだ。一見良いとこずくめだが、それだけだとPostCSSプラグインの実行に常にPostCSSが必要になってしまう。Node.jsモジュールとして機能しているかというと微妙なところだ。</description>
      <category>Coding</category>
      <guid isPermaLink="true">http://hail2u.net/blog/coding/postcss-plugin.html</guid>
      <pubDate>Thu, 11 Jun 2015 08:05:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p ><a href="https://github.com/postcss/postcss/releases/tag/4.1.0">PostCSS v4.1.0</a>からプラグインAPIが実装され、<code>postcss.plugin()</code>でプラグインを作ることが推奨されるようになった。この<a href="https://github.com/postcss/postcss/blob/master/docs/guidelines/plugin.md">ガイドライン</a>に従って作ることで、プラグイン間で一貫性が保たれ、エラーもわかりやすくなるというわけだ。一見良いとこずくめだが、それだけだとPostCSSプラグインの実行に常にPostCSSが必要になってしまう。Node.jsモジュールとして機能しているかというと微妙なところだ。</p>

<p>仮に<a href="https://github.com/hail2u/node-csswring">CSSWring</a>が<code>postcss.plugin()</code>だけを使って作り直されたとしてみよう。</p>

<pre><code >var fs = require(&quot;fs&quot;);
var postcss = require(&quot;postcss&quot;);
var csswring = require(&quot;csswring&quot;);

var input = &quot;main.css&quot;;
var output = &quot;main.min.css&quot;;

postcss([
  csswring()
]).process(fs.readFileSync(input, &quot;utf8&quot;), {
  from: input,
  to: output
}).then(function (result) {
  fs.writeFileSync(output, result.css);
});
</code></pre>

<p>PostCSSプラグインなので、このようにPostCSSの使い方をちゃんと知って使わざるをえない。もちろん他のPostCSSプラグインと組み合わせることもあるので、最終的にはこういう利用に落ち着くことはありうる。しかしCSSWringの機能のみを必要とする場合にもこう書かざるをえないのは無駄が多い。Autoprefixerのようにこういった形でコアを書き、別にラッパーを提供するという手もあるが、メンテナンスの手間が倍増することは確実だ。</p>

<p>また必要なPostCSSのバージョンを調べて、手作業で依存を解決しなくてはならないことも欠点になる。CSSWring側の<code>package.json</code>ですでに依存バージョンを明示していることを効果的に利用することができない。</p>

<pre><code >var fs = require(&quot;fs&quot;);
var csswring = require(&quot;csswring&quot;);

var input = &quot;main.css&quot;;
var output = &quot;main.min.css&quot;;

var result = csswring.wring(fs.readFileSync(input, &quot;utf8&quot;), {
  from: input,
  to: output
});
fs.writeFileSync(output, result.css);
</code></pre>

<p>CSSWringではこのように標準的なNode.jsモジュールのように利用することができる。Promiseではないことを考慮しても、コードは短くなっている。そもそもとしてPostCSSプラグインとしての使い方を知らなくても、はっきり言うのならPostCSSの存在を知らなくても書けるようになっている。</p>

<p>またこのスクリプトの<code>dependencies</code>からPostCSSが不要にもなる。つまり依存管理をモジュール側に任せることができるわけだ。</p>

<hr>

<p>プラグイン・システムというような方向から見ると、そういうデザインだとも言えるだろう。だがあるNode.jsモジュールを使う時にその依存モジュールの使い方をも知らなくてはならないという見方をするとどうだろうか。そんなことは知らなくてもそれ単体で使えるようになっているべきではないだろうか。</p>

<p>プラグイン・システムのような独自の生態系がいくつかのルール付けによって守られるようになると、同時にそれを内包する生態系(ここではNode.jsとnpm)との間に囲いを築くことにもなる。その囲いが低く感じられるか高く感じられるかはなんとも言えない。深くその独自の生態系について知れば、必要な高さの囲いだと納得できるかもしれないが、万人にそれを求めるのは酷だろう。</p>

<p>もちろんPostCSSプラグインはまったく悪いものではないし、PostCSSのプロセッサーとしてのみ機能するモジュールを書く場合に最も良い選択であることは確かだろう。ただそれだけではなく、Node.jsモジュールとしても単体で使えるようなインターフェイスも用意しておくことで、もっと使いやすくなるはずだ。</p>]]></content:encoded>
    </item>

    <item>
      <title>無限スクロール向け雑なローディング画像</title>
      <link>http://hail2u.net/blog/webdesign/easy-loading-marker-for-infinite-scroll.html</link>
      <description>無限スクロールはちょくちょく実装することはあるが、追加するコンテンツの読み込みや挿入はともかく、ローディング画像の処理で悩むことがある。その表示の切り替えには実装と処理のどちらにおいてもそこそこコストがかかるからだ。かなり前に色々考えるのが面倒になり、常に表示しておくという雑な手をよく使うようになった。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/easy-loading-marker-for-infinite-scroll.html</guid>
      <pubDate>Wed, 10 Jun 2015 03:15:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p >無限スクロールはちょくちょく実装することはあるが、追加するコンテンツの読み込みや挿入はともかく、ローディング画像の処理で悩むことがある。その表示の切り替えには実装と処理のどちらにおいてもそこそこコストがかかるからだ。かなり前に色々考えるのが面倒になり、常に表示しておくという雑な手をよく使うようになった。</p>

<p >View Demo: <a href="http://hail2u.net/pub/test/634.html">Easy Loading Marker for Infinite Scroll</a></p>

<p>デモでは90%ほどスクロールすると無限スクロールっぽくコンテンツが少し時間をおいてから追加される。コンテナーである<code>#content</code>の最下部には常にローディング画像を背景画像として表示してあるので、特に操作することなく無限スクロールのためにコンテンツを読込中であることを示すことができる。SVGアニメーションでローディング画像を作ったためInternet Explorer 11では回らないが、おおまかにどういう挙動をするのかはわかることだろう。</p>

<p>こういった雑なローディング画像の実装には利点が3つ挙げられる。</p>

<ul>
<li>コンテンツの読み込み以外のコードを書く必要がなくなる</li>
<li>ローディング画像が必要(とされそう)な時に即表示される</li>
<li>レンダリングのコストを下げられる</li>
</ul>

<section>
<h2>コード</h2>

<p>単純にローディング画像の挿入と削除を担当するコードがなくなり、ローディング画像の状態を保存する必要もなくなる。アニメーションGIFではなくスケーラブルにしたい場合も、デモのようにSVGアニメーションで完結させれば、HTMLへ空要素の挿入が必要ない(CSSでやる場合は擬似要素のアニメーションという点でいろいろあるので空要素などが必要になる)。もちろんCSSのコードが単純明快になるという点も見逃せない。</p>
</section>

<section>
<h2>ローディング画像の表示</h2>

<p>常に表示されているので、パフォーマンスを考慮したスクロール・イベントの間引きによる若干の遅延に影響を受けない。もちろんコンテンツの挿入そのもの自体は影響を受けるが、ローディング画像の表示においては影響を受けず、長めにアニメーションするだけになる。</p>
</section>

<section>
<h2>レンダリング・コスト</h2>

<p>画面外で常にアニメーションをさせることにはそれなりにコストはあるが、突然DOMに要素を追加(リフローやリレイアウト)し、アニメーションを開始(アニメーションの初期化コスト)するよりは低い。デモの場合はSVG内で完結させており、GPUのサポートも期待できる。</p>
</section>

<hr>

<p>欠点としては無限スクロール中のエラーに対して弱いことだ。追加コンテンツの読み込みとローディング画像の表示が完全に分離しているので、エラーが起きた時だけ両者を連動させる必要が出てくる。追加コンテンツの読み込み側ではエラー時にクラスを振るだけに留め、ローディング画像の表示と同じく簡単なCSSで見えなくしてやるのが妥当か。</p>

<hr>

<p>無限スクロールにおいては、ローディング画像などを表示することなく必要そうになる前に読み込み挿入しておく方が実装としては理想に近い。しかしその理想を実現するまでには、コンテンツを送る側のパフォーマンスやいつ読み込み始めるかのタイミング、ユーザーの回線への負担など解決が必要な問題がいくつもある。まずは実装ということを考えると、この雑なローディング画像は面倒がなく、便利に使っている。</p>]]></content:encoded>
    </item>

    <item>
      <title>夢</title>
      <link>http://hail2u.net/blog/misc/dreaming-20150603.html</link>
      <description>近くに昨日できた山が噴火する。そこから直径5mくらいの岩が降ってくるので、必死で避ける。避ける。3時間くらい避けたら岩の代わりにコインが降ってくるようになった。「コインだ！金だ！」と思って触ったら死んだ。ところで目が覚めた。</description>
      <category>Misc.</category>
      <guid isPermaLink="true">http://hail2u.net/blog/misc/dreaming-20150603.html</guid>
      <pubDate>Tue, 09 Jun 2015 04:29:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p >近くに昨日できた山が噴火する。そこから直径5mくらいの岩が降ってくるので、必死で避ける。避ける。3時間くらい避けたら岩の代わりにコインが降ってくるようになった。「コインだ！金だ！」と思って触ったら死んだ。ところで目が覚めた。</p>

<p>噴火の夢は何回か見たことがあるけど、実際に噴火を間近で見たことがないため、現実味に欠ける。桃鉄の噴火イベントみたいにドドドドって音がして、しばらくしたら上から岩が降ってくるだけ。煙や灰がまったくないので避けやすい。岩も普通の岩で熱いとかもない。</p>]]></content:encoded>
    </item>

  </channel>
</rss>
