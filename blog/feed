<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
  xml:lang="ja"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:creativeCommons="http://backend.userland.com/creativeCommonsRssModule"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Weblog - Hail2u.net</title>
    <link>http://hail2u.net/blog/</link>
    <description>ウェブ制作やウェブ標準の話題が中心ですが、それに限らず備忘録や日々の記録までを含めることで、10年以上続けることができたウェブログです。Blosxomを使って作られています。</description>
    <language>ja</language>
    <managingEditor>hail2u@gmail.com (Kyo Nagashima)</managingEditor>
    <lastBuildDate>Fri, 12 Jun 2015 07:39:48 +0900</lastBuildDate>
    <generator>blosxom v2.1.2+dev</generator>
    <atom:link rel="self" href="http://hail2u.net/blog/feed"/>
    <atom:link rel="hub" href="https://pubsubhubbub.appspot.com/"/>
    <creativeCommons:license>http://creativecommons.org/licenses/by-nc/3.0/</creativeCommons:license>


    <item>
      <title>オペラ座の怪人</title>
      <link>http://hail2u.net/blog/media/the-phantom-of-the-opera.html</link>
      <description>5年ぶりくらいに読みたくなったので本箱を漁っていたけどなかったので買った。前に読んだのは創元推理文庫版だったと思うので、今度は角川文庫版にした。確かにずいぶんと読みやすい気がする。文体の古さを噛み砕きながらまじめにゆっくりと読むのも好きだけど、読みやすいと連続で読む気になったりして、楽なのも悪くないなと最近は感じる。</description>
      <category>Media</category>
      <guid isPermaLink="true">http://hail2u.net/blog/media/the-phantom-of-the-opera.html</guid>
      <pubDate>Fri, 12 Jun 2015 07:39:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure >
  <a href="http://www.amazon.co.jp/gp/product/4042840019/ref=as_li_ss_il?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4042840019&amp;linkCode=as2&amp;tag=hail2unet-22"><img alt="オペラ座の怪人 (角川文庫)" src="http://ecx.images-amazon.com/images/I/41JQWRT9N9L.jpg" ></a>
</figure>

<p >5年ぶりくらいに読みたくなったので本箱を漁っていたけどなかったので買った。前に読んだのは創元推理文庫版だったと思うので、今度は角川文庫版にした。確かにずいぶんと読みやすい気がする。文体の古さを噛み砕きながらまじめにゆっくりと読むのも好きだけど、読みやすいと連続で読む気になったりして、楽なのも悪くないなと最近は感じる。</p>

<p>ここ10年くらいで一気にこれと同時代の文学が再翻訳されつつある。あれであれなあれの事情が解消されたからか。僕は和洋を問わずだいたいこの辺りの時代の文学が好きなため、若干古めかしく読みづらいとも言える古い文体での翻訳も好き。古さを意識しながら読めるからとか、現代を忘れられるからとか。ただ再翻訳では誤訳や何かの都合で省かれた部分が修正されたりするため、気になって欲しくなったりするのでずるい。</p>

<hr>

<p>やっぱり災厄の町の新訳版が欲しくなってきた。完全な電子書籍時代になると、もしかしたらこういった新訳も無料か安価に手に入れられたりするようになるのかな。</p>]]></content:encoded>
    </item>

    <item>
      <title>PostCSSプラグイン</title>
      <link>http://hail2u.net/blog/coding/postcss-plugin.html</link>
      <description>PostCSS v4.1.0からプラグインAPIが実装され、postcss.plugin()でプラグインを作ることが推奨されるようになった。このガイドラインに従って作ることで、プラグイン間で一貫性が保たれ、エラーもわかりやすくなるというわけだ。一見良いとこずくめだが、それだけだとPostCSSプラグインの実行に常にPostCSSが必要になってしまう。Node.jsモジュールとして機能しているかというと微妙なところだ。</description>
      <category>Coding</category>
      <guid isPermaLink="true">http://hail2u.net/blog/coding/postcss-plugin.html</guid>
      <pubDate>Thu, 11 Jun 2015 08:05:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p ><a href="https://github.com/postcss/postcss/releases/tag/4.1.0">PostCSS v4.1.0</a>からプラグインAPIが実装され、<code>postcss.plugin()</code>でプラグインを作ることが推奨されるようになった。この<a href="https://github.com/postcss/postcss/blob/master/docs/guidelines/plugin.md">ガイドライン</a>に従って作ることで、プラグイン間で一貫性が保たれ、エラーもわかりやすくなるというわけだ。一見良いとこずくめだが、それだけだとPostCSSプラグインの実行に常にPostCSSが必要になってしまう。Node.jsモジュールとして機能しているかというと微妙なところだ。</p>

<p>仮に<a href="https://github.com/hail2u/node-csswring">CSSWring</a>が<code>postcss.plugin()</code>だけを使って作り直されたとしてみよう。</p>

<pre><code >var fs = require(&quot;fs&quot;);
var postcss = require(&quot;postcss&quot;);
var csswring = require(&quot;csswring&quot;);

var input = &quot;main.css&quot;;
var output = &quot;main.min.css&quot;;

postcss([
  csswring()
]).process(fs.readFileSync(input, &quot;utf8&quot;), {
  from: input,
  to: output
}).then(function (result) {
  fs.writeFileSync(output, result.css);
});
</code></pre>

<p>PostCSSプラグインなので、このようにPostCSSの使い方をちゃんと知って使わざるをえない。もちろん他のPostCSSプラグインと組み合わせることもあるので、最終的にはこういう利用に落ち着くことはありうる。しかしCSSWringの機能のみを必要とする場合にもこう書かざるをえないのは無駄が多い。Autoprefixerのようにこういった形でコアを書き、別にラッパーを提供するという手もあるが、メンテナンスの手間が倍増することは確実だ。</p>

<p>また必要なPostCSSのバージョンを調べて、手作業で依存を解決しなくてはならないことも欠点になる。CSSWring側の<code>package.json</code>ですでに依存バージョンを明示していることを効果的に利用することができない。</p>

<pre><code >var fs = require(&quot;fs&quot;);
var csswring = require(&quot;csswring&quot;);

var input = &quot;main.css&quot;;
var output = &quot;main.min.css&quot;;

var result = csswring.wring(fs.readFileSync(input, &quot;utf8&quot;), {
  from: input,
  to: output
});
fs.writeFileSync(output, result.css);
</code></pre>

<p>CSSWringではこのように標準的なNode.jsモジュールのように利用することができる。Promiseではないことを考慮しても、コードは短くなっている。そもそもとしてPostCSSプラグインとしての使い方を知らなくても、はっきり言うのならPostCSSの存在を知らなくても書けるようになっている。</p>

<p>またこのスクリプトの<code>dependencies</code>からPostCSSが不要にもなる。つまり依存管理をモジュール側に任せることができるわけだ。</p>

<hr>

<p>プラグイン・システムというような方向から見ると、そういうデザインだとも言えるだろう。だがあるNode.jsモジュールを使う時にその依存モジュールの使い方をも知らなくてはならないという見方をするとどうだろうか。そんなことは知らなくてもそれ単体で使えるようになっているべきではないだろうか。</p>

<p>プラグイン・システムのような独自の生態系がいくつかのルール付けによって守られるようになると、同時にそれを内包する生態系(ここではNode.jsとnpm)との間に囲いを築くことにもなる。その囲いが低く感じられるか高く感じられるかはなんとも言えない。深くその独自の生態系について知れば、必要な高さの囲いだと納得できるかもしれないが、万人にそれを求めるのは酷だろう。</p>

<p>もちろんPostCSSプラグインはまったく悪いものではないし、PostCSSのプロセッサーとしてのみ機能するモジュールを書く場合に最も良い選択であることは確かだろう。ただそれだけではなく、Node.jsモジュールとしても単体で使えるようなインターフェイスも用意しておくことで、もっと使いやすくなるはずだ。</p>]]></content:encoded>
    </item>

    <item>
      <title>無限スクロール向け雑なローディング画像</title>
      <link>http://hail2u.net/blog/webdesign/easy-loading-marker-for-infinite-scroll.html</link>
      <description>無限スクロールはちょくちょく実装することはあるが、追加するコンテンツの読み込みや挿入はともかく、ローディング画像の処理で悩むことがある。その表示の切り替えには実装と処理のどちらにおいてもそこそこコストがかかるからだ。かなり前に色々考えるのが面倒になり、常に表示しておくという雑な手をよく使うようになった。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/easy-loading-marker-for-infinite-scroll.html</guid>
      <pubDate>Wed, 10 Jun 2015 03:15:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p >無限スクロールはちょくちょく実装することはあるが、追加するコンテンツの読み込みや挿入はともかく、ローディング画像の処理で悩むことがある。その表示の切り替えには実装と処理のどちらにおいてもそこそこコストがかかるからだ。かなり前に色々考えるのが面倒になり、常に表示しておくという雑な手をよく使うようになった。</p>

<p >View Demo: <a href="http://hail2u.net/pub/test/634.html">Easy Loading Marker for Infinite Scroll</a></p>

<p>デモでは90%ほどスクロールすると無限スクロールっぽくコンテンツが少し時間をおいてから追加される。コンテナーである<code>#content</code>の最下部には常にローディング画像を背景画像として表示してあるので、特に操作することなく無限スクロールのためにコンテンツを読込中であることを示すことができる。SVGアニメーションでローディング画像を作ったためInternet Explorer 11では回らないが、おおまかにどういう挙動をするのかはわかることだろう。</p>

<p>こういった雑なローディング画像の実装には利点が3つ挙げられる。</p>

<ul>
<li>コンテンツの読み込み以外のコードを書く必要がなくなる</li>
<li>ローディング画像が必要(とされそう)な時に即表示される</li>
<li>レンダリングのコストを下げられる</li>
</ul>

<section>
<h2>コード</h2>

<p>単純にローディング画像の挿入と削除を担当するコードがなくなり、ローディング画像の状態を保存する必要もなくなる。アニメーションGIFではなくスケーラブルにしたい場合も、デモのようにSVGアニメーションで完結させれば、HTMLへ空要素の挿入が必要ない(CSSでやる場合は擬似要素のアニメーションという点でいろいろあるので空要素などが必要になる)。もちろんCSSのコードが単純明快になるという点も見逃せない。</p>
</section>

<section>
<h2>ローディング画像の表示</h2>

<p>常に表示されているので、パフォーマンスを考慮したスクロール・イベントの間引きによる若干の遅延に影響を受けない。もちろんコンテンツの挿入そのもの自体は影響を受けるが、ローディング画像の表示においては影響を受けず、長めにアニメーションするだけになる。</p>
</section>

<section>
<h2>レンダリング・コスト</h2>

<p>画面外で常にアニメーションをさせることにはそれなりにコストはあるが、突然DOMに要素を追加(リフローやリレイアウト)し、アニメーションを開始(アニメーションの初期化コスト)するよりは低い。デモの場合はSVG内で完結させており、GPUのサポートも期待できる。</p>
</section>

<hr>

<p>欠点としては無限スクロール中のエラーに対して弱いことだ。追加コンテンツの読み込みとローディング画像の表示が完全に分離しているので、エラーが起きた時だけ両者を連動させる必要が出てくる。追加コンテンツの読み込み側ではエラー時にクラスを振るだけに留め、ローディング画像の表示と同じく簡単なCSSで見えなくしてやるのが妥当か。</p>

<hr>

<p>無限スクロールにおいては、ローディング画像などを表示することなく必要そうになる前に読み込み挿入しておく方が実装としては理想に近い。しかしその理想を実現するまでには、コンテンツを送る側のパフォーマンスやいつ読み込み始めるかのタイミング、ユーザーの回線への負担など解決が必要な問題がいくつもある。まずは実装ということを考えると、この雑なローディング画像は面倒がなく、便利に使っている。</p>]]></content:encoded>
    </item>

    <item>
      <title>夢</title>
      <link>http://hail2u.net/blog/misc/dreaming-20150603.html</link>
      <description>近くに昨日できた山が噴火する。そこから直径5mくらいの岩が降ってくるので、必死で避ける。避ける。3時間くらい避けたら岩の代わりにコインが降ってくるようになった。「コインだ！金だ！」と思って触ったら死んだ。ところで目が覚めた。</description>
      <category>Misc.</category>
      <guid isPermaLink="true">http://hail2u.net/blog/misc/dreaming-20150603.html</guid>
      <pubDate>Tue, 09 Jun 2015 04:29:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p >近くに昨日できた山が噴火する。そこから直径5mくらいの岩が降ってくるので、必死で避ける。避ける。3時間くらい避けたら岩の代わりにコインが降ってくるようになった。「コインだ！金だ！」と思って触ったら死んだ。ところで目が覚めた。</p>

<p>噴火の夢は何回か見たことがあるけど、実際に噴火を間近で見たことがないため、現実味に欠ける。桃鉄の噴火イベントみたいにドドドドって音がして、しばらくしたら上から岩が降ってくるだけ。煙や灰がまったくないので避けやすい。岩も普通の岩で熱いとかもない。</p>]]></content:encoded>
    </item>

    <item>
      <title>list-style-type: "🆕";</title>
      <link>http://hail2u.net/blog/webdesign/list-style-type-string.html</link>
      <description>Firefox 39からlist-style-typeプロパティーで文字列が使えるようになる。今までは文字列を使おうとすると擬似要素経由で行うことになったため、デフォルトで要素の外側に配置されるリスト・マーカーと違和感のないように行うのはなかなか難しかった。そういった点が解決しやすくなったことや、Emojiを利用したリスト・マーカーなど、明快に広がる使い勝手の良さもあるが、他にも横並びのリストの区切りが作りやすくなる。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/list-style-type-string.html</guid>
      <pubDate>Mon, 08 Jun 2015 03:47:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p ><a href="https://developer.mozilla.org/en-US/Firefox/Releases/39">Firefox 39</a>から<code>list-style-type</code>プロパティーで文字列が使えるようになる。今までは文字列を使おうとすると擬似要素経由で行うことになったため、デフォルトで要素の外側に配置されるリスト・マーカーと違和感のないように行うのはなかなか難しかった。そういった点が解決しやすくなったことや、Emojiを利用したリスト・マーカーなど、明快に広がる使い勝手の良さもあるが、他にも横並びのリストの区切りが作りやすくなる。</p>

<p >View Demo: <a href="http://hail2u.net/pub/test/633.html">list-style-type: &quot;string&quot;</a></p>

<p>デモでは横並びのリストの区切りにMiddle Dot (<code>·</code>)を使っている。ウェブサイトのフッターにあるリンク・リストなどでよくみる形のものだ。擬似要素でやる場合は、<code>li</code>要素のスタイルのリセットに加えて擬似要素の追加が必要になるが、<code>list-style-type</code>プロパティーが使える場合はずっと簡単になる。</p>

<pre><code >li {
  float: left;
  list-style-position: inside;
  list-style-type: &quot; · &quot;;
}

li:first-child {
  list-style-type: &quot;&quot;;
}
</code></pre>

<p>擬似要素を使う場合と比べて少しシンプルに、そして直感的なコードになっていることと思う。リスト項目と区切りの間の空白も文字列でコントロールすることができるので、文字列ベースの区切りにはもってこいだろう。ただし連続した空白はもちろんまとめられるので、非改行スペース(<code>\a0</code>)をうまく使うときれいに調節することができる。</p>

<p>区切りに使える文字列の自由度はかなり高い。Emojiもそうだが、ユニコードで定義されている<a href="http://en.wikipedia.org/wiki/Unicode_symbols">多くのシンボル文字</a>を使うことももちろん出来る。サブセット化したアイコン・フォントとも相性が良いと考えられるが、それは素直にSVGにして<code>list-style-image</code>プロパティーで参照した方が良いだろう。</p>

<hr>

<p>この<code>list-style-type</code>プロパティーにおける文字列の利用は、随分前から仕様では定義されていた(<a href="http://www.w3.org/TR/2011/WD-css3-lists-20110524/">2011/05/24付けのWorking Draft</a>からのようだ)が、実装は今月にリリースをひかえるFirefox 39が最初となる。そのため気軽に使えるようになるまではかなりの時間がかかることだろう。このような具体的で実践的な利用例を挙げることで、実装が進むことを期待したい。</p>]]></content:encoded>
    </item>

    <item>
      <title>カラースキームのアップデート</title>
      <link>http://hail2u.net/blog/webdesign/updating-color-scheme.html</link>
      <description>このウェブサイトのカラースキームを少し変えた。ベースとなるアクセント・カラーを#1188bbから#278dd2と少し青を強くした。並べて比較するとわかるといった程度の違いで、ほとんど変わっていない。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/updating-color-scheme.html</guid>
      <pubDate>Sun, 07 Jun 2015 02:34:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p >このウェブサイトのカラースキームを少し変えた。ベースとなるアクセント・カラーを<code style="background-color:#1188bb;color:#fff">#1188bb</code>から<code style="background-color:#278dd2;color:#fff">#278dd2</code>と少し青を強くした。並べて比較するとわかるといった程度の違いで、ほとんど変わっていない。</p>

<p>多くの場合、こういったカラースキームの微調整には長い期間が必要になる。短期間に比較で行うと、微妙な違いが強調されて認識されてしまうため、自分の認識と実際の変化に大きなズレが生じてしまう。第三者に何も言わず見せ、ブラインド・テストを行うとすんなりおかしいところが発見できるが、少人数で開発している場合はそういったフラットな状態で確認することは難しいので、長い期間をかけてじっくりと確認する必要がある。</p>

<p>今回は<code style="background-color:#1188bb;color:#fff">#1188bb</code>から<code style="background-color:#3399ff;color:#fff">#3399ff</code>までの間で色々試した結果、3ヶ月ほどで<code style="background-color:#278dd2;color:#fff">#278dd2</code>に落ち着いた。通常の背景とのコントラスト比は<code>3.42</code>で<code>4.5</code>にはかなり足らないが、本文に使うわけではないのでこれまで通り目をつぶっておく。</p>]]></content:encoded>
    </item>

    <item>
      <title>スプレーとスティック、そしてクリーム</title>
      <link>http://hail2u.net/blog/gadget/spray-stick-cream.html</link>
      <description>制汗のアレの話。スプレーでおっつかなくなったので、デオナチュレのスティックをこの2年使っていたのだけど、これは長く硬いワキ毛とは相性が悪く、うまく塗れてなかったことがよくあった。さすがにワキ毛を剃るのはためらうので、メンソレータムが出してるクリーム状のしっかりと塗れるやつに乗り換えた。脇汗8割減という感じで、効能としては満足はしている。</description>
      <category>Gadget</category>
      <guid isPermaLink="true">http://hail2u.net/blog/gadget/spray-stick-cream.html</guid>
      <pubDate>Sat, 06 Jun 2015 01:14:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure >
  <a href="http://www.amazon.co.jp/gp/product/B00TJEOIJC/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=B00TJEOIJC&amp;linkCode=as2&amp;tag=hail2unet-22"><img alt="リフレア デオドラントクリーム 25g (医薬部外品)" src="http://ecx.images-amazon.com/images/I/41WlPC019dL.jpg" ></a>
</figure>

<p >制汗のアレの話。スプレーでおっつかなくなったので、デオナチュレのスティックをこの2年使っていたのだけど、これは長く硬いワキ毛とは相性が悪く、うまく塗れてなかったことがよくあった。さすがにワキ毛を剃るのはためらうので、<a href="http://www.amazon.co.jp/gp/product/B00TJEOIJC/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=B00TJEOIJC&amp;linkCode=as2&amp;tag=hail2unet-22">メンソレータムが出してるクリーム状のしっかりと塗れるやつ</a>に乗り換えた。脇汗8割減という感じで、効能としては満足はしている。</p>

<p>クリームやジェル状のは知らなかったんだけど、<a href="http://www.amazon.co.jp/gp/product/B00SM997IW/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=B00SM997IW&amp;linkCode=as2&amp;tag=hail2unet-22">エイトフォーの出してるすごい高い個包装のやつ</a>を貰ったたらとんでもなかった。まるで汗がでなくて怖い感じだった。でもさすがにこれは高すぎ(3gで600円)だったので、無香料ということで香りで誤魔化すタイプではないんだろうとメンソレータムのものにした。</p>

<p>スティックのものと比べヌルヌル感が残るので、ちょっとアレな感じになるのと、服にちょっとついたりするのが難点。慣れればうまく塗れるようにはなりそう。最終的には大容量タイプので落ち着きたい。</p>

<hr>

<p>効能に「わきが」って書いてあるとダメージ大きいので、なんかこうもっと工夫した文言を編み出して欲しい。</p>]]></content:encoded>
    </item>

    <item>
      <title>node-inlining</title>
      <link>http://hail2u.net/blog/software/node-inlining.html</link>
      <description>HTMLからlink要素で参照しているCSSの中身をstyle属性に全部展開するNode.jsパッケージ、node-inliningを書いていた。HTMLとCSSを別々に普通に書き、このパッケージに含まれるCLIプログラムでコンパイルすると、HTMLメールとしてうまく機能するHTMLができあがるということになる。GitHubで推奨されている外部リソースに依存しない静的なエラー・ページを作成するためにも使えるかもしれない。</description>
      <category>Software</category>
      <guid isPermaLink="true">http://hail2u.net/blog/software/node-inlining.html</guid>
      <pubDate>Fri, 05 Jun 2015 00:57:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p >HTMLから<code>link</code>要素で参照しているCSSの中身を<code>style</code><em>属性</em>に全部展開するNode.jsパッケージ、<a href="https://github.com/hail2u/node-inlining">node-inlining</a>を書いていた。HTMLとCSSを別々に普通に書き、このパッケージに含まれるCLIプログラムでコンパイルすると、HTMLメールとしてうまく機能するHTMLができあがるということになる。GitHubで推奨されている外部リソースに依存しない静的なエラー・ページを作成するためにも使えるかもしれない。</p>

<p>CLIプログラムはごく簡単に使うことができる。</p>

<pre><samp>$ <kbd>npm install -g inlining</kbd>
$ <kbd>inlining input.html &gt;output.html</kbd>
</samp></pre>

<p>これで<code>output.html</code>にインライン化されたHTMLファイルが吐かれる。処理例は<a href="https://github.com/hail2u/node-inlining#readme">README</a>の簡単な例や<a href="https://github.com/hail2u/node-inlining/tree/master/test">testディレクトリー</a>を見てくれればわかるはずだ。</p>

<p>Node.jsパッケージとしての利用は少しややこしくなる。</p>

<pre><code >var inlining = require(&quot;inlining&quot;);
inlining(fs.readFileSync(&quot;input.html&quot;, &quot;utf8&quot;), function (result) {
  console.log(result);
});
</code></pre>

<p>引数は以下の3つになる。</p>

<ol>
<li>HTMLコード</li>
<li>HTMLファイルの(想定される)パス (省略可能)</li>
<li>コールバック</li>
</ol>

<p>HTMLコードを直接渡すと処理して、コールバック関数が処理結果を引数として実行される。HTMLファイルのパスは相対パスを解決するために使っている。省略した場合はカレント・ディレクトリーになる。</p>

<hr>

<p>パッケージ内では以下の様な順で処理される。</p>

<ol>
<li><code>rel=&quot;stylesheet&quot;</code>である<code>link</code>要素を列挙<ol>
<li><code>href</code>属性の値をパスとして解決</li>
<li>CSSを読み込んでパース<ol>
<li>読み込みに失敗したらスキップして次の<code>link</code>要素へ</li>
</ol>
</li>
<li>ルールセットのセレクターを分割<ol>
<li>セレクターにマッチする要素を列挙</li>
<li>ルールセットの中身を連結して、<code>style</code>属性の値に設定</li>
</ol>
</li>
<li>ルールセットを削除</li>
<li>残ったCSSを<code>style</code>要素の中身として<code>head</code>要素に追加</li>
<li><code>link</code>要素を削除</li>
</ol>
</li>
<li>処理結果を標準出力に出力</li>
</ol>

<p><code>@media</code>ルールなどの<code>style</code>属性へ記述できないルールセット群はそのまま残り、出力HTMLの<code>head/style</code>にそのままコピーされることになる。ここで詳細度が逆転してしまう可能性があるので、<code>@media</code>ルールで上書きしたい場合は<code>!important</code>フラグを駆使する必要がある。他、相対パスで指定された画像ファイルなどはDataURLで埋め込まれる。</p>

<hr>

<p>内部ではHTMLをパースしてDOM API群を提供してくれる<a href="https://github.com/tmpvar/jsdom">jsdomパッケージ</a>とおなじみCSSをパースしてくれる<a href="https://github.com/postcss/postcss">postcssパッケージ</a>を利用した。jsdomはその存在は知っていたものの、初めてまともに使った。概ね使いやすかったが、やはりバグとはいえないまでも、いくつか特徴的な挙動は持つようだ。</p>

<p>例えばjsdomで<code>HTMLElement.style.cssText</code>を使うとノーマライズされてしまう。そのためベンダー拡張プリフィックス付きのプロパティーや存在しないプロパティー(<code>foo</code>とか)、そして未知のプロパティー(<code>font-feature-settings</code>プロパティーとか)がうまく追加できなかった。仕方がないので<code>Element.setAttribute()</code>を使って強引にそのまま設定している。</p>

<p>また<code>querySelectorAll()</code>で<code>::-moz-selection</code>擬似要素を含むものなど不明なセレクターを投げるとブラウザーと同じように例外を吐く。ブラウザーではそのまま処理は続行されるが、Node.js上では当然落ちる。使いづらいが挙動としては正しそうなため、<code>try..catch</code>で握りつぶして無視した。</p>

<p>最後に完全なHTMLソースを手に入れることに少し苦労した。<code>window.document.documentElement.innerHTML</code>だと<code>html</code>要素が除外され、<code>window.document.documentElement.outerHTML</code>だとDOCTYPEが拾えない。<code>window.document.doctype</code>を使って連結するのは少しややこしすぎる。どうやら専用の非標準APIが用意されているようで、それを使うとうまく手に入れられた。</p>

<pre><code >var jsdom = require(&quot;jsdom&quot;);

jsdom.env(
  &quot;&lt;!DOCTYPE html&gt;&lt;p&gt;Lorem ipsum&lt;/p&gt;&quot;,
  function (errors, window) {
    console.log(window.document.documentElement.innerHTML);
    // &lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Lorem ipsum&lt;/p&gt;&lt;/body&gt;
    console.log(window.document.documentElement.outerHTML);
    // &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Lorem ipsum&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
    console.log(<mark>jsdom.serializeDocument(window.document)</mark>);
    // &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Lorem ipsum&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
  }
);
</code></pre>

<p>他、MIMEタイプの推定には<a href="https://github.com/broofa/node-mime"><code>mime</code></a>パッケージ、画像のDataURL化には<a href="https://nodejs.org/api/buffer.html#buffer_buf_tostring_encoding_start_end"><code>Buffer.toString(&quot;base64&quot;)</code></a>に当たるものを利用した。</p>

<hr>

<p>とりあえず動くところまでという形で書いた。続きはわからないけれど、必要な機能はもうあまりなさそうだ。強いて言うのならHTMLファイル内の画像ファイルのDataURL化くらいだろうか。</p>]]></content:encoded>
    </item>

    <item>
      <title>Material DesignのFloating Action Button</title>
      <link>http://hail2u.net/blog/software/fab.html</link>
      <description>マテリアル・デザインのコンポーネントのひとつであるFloating Action Buttonsについての記事を読んでいた。Inbox by Googleを始めとして、さまざまなアプリに既に採用されているFloating Action Buttons (以下FAB)だが、主張が強すぎるため、没入型のアプリではその体験を阻害してしまうという話のようだ。</description>
      <category>Software</category>
      <guid isPermaLink="true">http://hail2u.net/blog/software/fab.html</guid>
      <pubDate>Thu, 04 Jun 2015 03:08:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p ><a href="https://medium.com/tech-in-asia/material-design-why-the-floating-action-button-is-bad-ux-design-acd5b32c5ef">マテリアル・デザインのコンポーネントのひとつであるFloating Action Buttonsについての記事</a>を読んでいた。Inbox by Googleを始めとして、さまざまなアプリに既に採用されている<a href="http://www.google.com/design/spec/components/buttons-floating-action-button.html">Floating Action Buttons</a> (以下FAB)だが、主張が強すぎるため、没入型のアプリではその体験を阻害してしまうという話のようだ。</p>

<p>そういうものだ、という捉え方ももちろんできる。しかしマテリアル・デザインのガイドでプライマリー・アクションに使うものと定義されていて、かつアクション・バーにボタンが配置できる以上、わざわざコンテンツにかぶる形で置く必要はあまりないだろう。もしアクション・バーのボタンを使いつつとなると、記事でも触れられているように、そのFABには間違ったアクションを割り当てていることになる。</p>

<p>他、単純にインターフェイスとして欠陥があることも指摘している。FABとかぶる位置にしか表示できないものが見えない、またはアクションが実行できないというものだ。具体例として、リスト項目で日付表示やお気に入りボタンを右端に配置した場合、右下にFABを配置してしまうと、リストの最後の項目の日付表示が見えず、お気に入りボタンはタッチできなくなってしまうことを挙げている。これは構造的に欠陥がありそうだ。</p>

<p>ガイドラインに抵触することを承知の上でFABの見た目を変えれば、その存在感を薄めることは可能だが、それは同時にそのFABに割り当てられたアクションの存在意義が薄くても構わないことを意味する。それではFAB自体の定義と矛盾してしまう。</p>

<p>FABはその明快な定義とは裏腹に、見えない部分に矛盾をいくつか抱えたコンポーネントだということになりそうだ。</p>]]></content:encoded>
    </item>

    <item>
      <title>扇風機</title>
      <link>http://hail2u.net/blog/gadget/pedestal-fan.html</link>
      <description>もう夏なので扇風機を出した。震災後に買った口で、もう4年目。まだまだきれいだし、あと10年くらいは使えそうだ。</description>
      <category>Gadget</category>
      <guid isPermaLink="true">http://hail2u.net/blog/gadget/pedestal-fan.html</guid>
      <pubDate>Wed, 03 Jun 2015 13:36:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure >
  <a href="http://hail2u.net/images/blog/pedestal-fan.jpg"><img alt="無印良品の真っ白なリモコン付き扇風機" height="2868" src="http://hail2u.net/images/blog/pedestal-fan.jpg" width="2448" ></a>
</figure>

<p >もう夏なので扇風機を出した。震災後に買った口で、もう4年目。まだまだきれいだし、あと10年くらいは使えそうだ。</p>

<p>サーキュレーターは毎年買おうと思うけど、結局買わない。うるさいのは我慢できそうだけど、なんだかんだで部屋にあると邪魔に感じそうといつも思ってしまう。特に電源コード。今年はむしろ扇風機をもう1台買ってしまいそうだけれど、これも邪魔だし、こっちはこっちでしまう場所を考えるのが面倒で買わなそう。</p>

<hr>

<p>物を増やすことにすごく抵抗があって、すぐに買わない理由を考えてしまう。なんかこう強制的に買い換えるイベントでもないと解呪できなそうだ。こういうこと言うと天災に見舞われて家財道具一式が藻屑になるとかありそう。</p>]]></content:encoded>
    </item>

  </channel>
</rss>
