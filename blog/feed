<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
  xml:lang="ja"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:creativeCommons="http://backend.userland.com/creativeCommonsRssModule"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Weblog - Hail2u.net</title>
    <link>http://hail2u.net/blog/</link>
    <description>ウェブ制作やウェブ標準の話題が中心ですが、それに限らず備忘録や日々の記録までを含めることで、10年以上続けることができたウェブログです。Blosxomを使って作られています。</description>
    <language>ja</language>
    <managingEditor>hail2u@gmail.com (Kyo Nagashima)</managingEditor>
    <lastBuildDate>Thu, 17 Sep 2015 08:46:47 +0900</lastBuildDate>
    <generator>blosxom v2.1.2+dev</generator>
    <atom:link rel="self" href="http://hail2u.net/blog/feed"/>
    <atom:link rel="hub" href="https://pubsubhubbub.appspot.com/"/>
    <creativeCommons:license>http://creativecommons.org/licenses/by-nc/3.0/</creativeCommons:license>


    <item>
      <title>レスポンシブ・タイポグラフィーなど</title>
      <link>http://hail2u.net/blog/webdesign/on-responsive-typography.html</link>
      <description>ウィンドウや画面のサイズに合わせて文字の大きさを自動的に変更するテクニックは、俗にレスポンシブ・タイポグラフィーまたはフルイド・タイプと呼ばれている。当初は僕も良いアイディアだと思い多用していたが、重要なのはビューポートの大きさではなくデバイスとの距離だろうと思い直したためもうほとんど使うことはない。当初から嫌いといっていた人はこの辺にしっかりとした意識があったのだろう。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/on-responsive-typography.html</guid>
      <pubDate>Thu, 17 Sep 2015 08:46:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>ウィンドウや画面のサイズに合わせて文字の大きさを自動的に変更するテクニックは、俗に<a href="http://www.smashingmagazine.com/2015/06/responsive-typography-with-sass-maps/">レスポンシブ・タイポグラフィー</a>または<a href="http://trentwalton.com/2012/06/19/fluid-type/">フルイド・タイプ</a>と呼ばれている。当初は僕も良いアイディアだと思い多用していたが、重要なのはビューポートの大きさではなく<em>デバイスとの距離</em>だろうと思い直したためもうほとんど使うことはない。当初から嫌いといっていた人はこの辺にしっかりとした意識があったのだろう。</p>

<p>使うことをやめた理由は、単純に技術的制約によってユーザーとデバイスの距離を知るすべがないからに過ぎない。レスポンシブ・タイポグラフィーが目指す、適切な文字の大きさを環境ごとに提示することそのものについては正しい考え方であると思う。ただ今利用されている「ビューポートが768px以下なら文字を小さめにする」というようなアバウトな実装だと問題がある。もちろん<code>vw</code>単位を使ったフォント・サイズ指定でも同じだ。</p>

<p>なぜならばデスクトップPCでもそれくらいのビューポートになるようなウィンドウ・サイズでブラウザーを開いているかもしれないからだ。TwitterやFacebookを小さいウィンドウでデスクトップの端に表示しておくことはよくあるだろう。その場合ユーザーとデバイスの距離がある程度あるにもかかわらず文字が小さくなってしまうため、制作者が意図した読みやすさにはならない。iOS 9のアプリ分割表示なども（致命的ではなさそうではあるが）それに類する状況となるかもしれない。</p>

<p>つまり<em>ビューポートの大きさとデバイスとの距離は一貫した関係にない</em>ということだ。これくらいのビューポートならデバイスとの距離はこれくらいだろう、とはならない。つまりそういったギャップを想定していない実装には大きな問題があるということになる。</p>

<hr>

<p>ユーザーとデバイスとの距離を決定付ける要因は以下の4つになるように思う。</p>

<ol>
<li>画面サイズ</li>
<li>タッチ操作可能かどうか</li>
<li>可搬性</li>
<li>重量</li>
<li>設置（利用）場所</li>
</ol>

<p>1と2は今でも知ることができるが、3から5はなかなか難しそうだ。例えば<a href="https://www.microsoft.com/microsoft-surface-hub/ja-jp">Surface Hub</a>のようなものは設置場所（壁か机か）によってユーザーとの距離が大きく変わるデバイスで、デバイスの特定が距離の判定にはつながらない。もちろん普通のSurfaceのようないわゆる2in1も机に置いて使う場合と手で持って使う場合で距離は変化するので、これもまた距離を判定することはできない。</p>

<p>ジャイロ・センサーのようなものがあるなら手に持たれているかどうかは判定可能だと思うので、レスポンシブ・タイポグラフィーは完全な絵空事とまでは言えない。しかし「レスポンシブ」と付くその魅惑的な名前とは裏腹に、今は実装が非常に難しい、またはほとんど不可能なテクニックであると言って良いだろう。</p>

<hr>

<p>どうしても実装したいのならCSSで行うよりもJavaScriptでデバイス（ビューポートではなく）を特定し、ページ読み込み時に一度だけフォント・サイズを設定するというようなやり方が良さそうだ。デフォルトのフォントサイズをベースラインとして提供した上で、なんとかデバイスとの距離を判定することができそうなスマホやデスクトップPCなどのみに限って調整してやるに留めるという形にできるだろう。</p>

<p>パフォーマンスや振る舞いを考えるとCSSで<code>*-device-width</code>を使ってやりたいところだが、画面に直接触れるタブレット機器と触れることのないモバイル・ノートブックPCを同じにみなすことになりかねず、うまくいかないだろう。<a href="http://www.w3.org/TR/mediaqueries-4/#issue-e310bdfa">Media Queries 4で削除される方向</a>で話が進んでいることも避ける理由になる（このあたりの話を聞いた時にデバイスとの距離を参照できる機能が追加されるというような話をどこかで聞いたような気がするが定かではない）。</p>]]></content:encoded>
    </item>

    <item>
      <title>FOUTはプログレッシブ・エンハンスメントだ</title>
      <link>http://hail2u.net/blog/webdesign/fout-is-progressive-enhancement.html</link>
      <description>僕はウェブフォントの実装はFOUTを強いる形がベストだと今のところは考えている。とにかく文章が読める状態をできる限り確保するべきだと思うからだ。だがなかなかFOUTの良さを説明することは難しい。どうしても他の手法の欠点を強調しがちで終わっていた。そういう時にFOUTをプログレッシブ・エンハンスメントととらえて説明するのは良さそうだ。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/fout-is-progressive-enhancement.html</guid>
      <pubDate>Tue, 15 Sep 2015 08:01:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure >
  <a href="https://twitter.com/kay_spiegel/status/643374629176934400"><img alt="FOUT is Progressive Enhancement" height="627" src="http://hail2u.net/images/blog/fout-is-progressive-enhancement.png" width="1200"></a>
</figure>

<p>僕はウェブフォントの実装はFOUTを強いる形がベストだと今のところは考えている。とにかく文章が読める状態をできる限り確保するべきだと思うからだ。だがなかなかFOUTの良さを説明することは難しい。どうしても他の手法の欠点を強調しがちで終わっていた。そういう時に<a href="https://twitter.com/kay_spiegel/status/643374629176934400">FOUTをプログレッシブ・エンハンスメント</a>ととらえて説明するのは良さそうだ。</p>

<p>ウェブフォントの読み込み状況と文書のレンダリング状態を分けてとらえ、前者の状況の変化を後者へと<em>段階的に反映させる</em>というわけだ。そうすることで常に最低限の形で文書が表示されることが担保され、ネットワーク状況の劣悪さにユーザーの読者としての体験が左右されなくなる。</p>

<hr>

<p>このウェブサイトではFOUTに近い形になるようにしているが、ウェブフォントを読み込むためのCSSを非同期に読み込ませているだけだ。<a href="http://www.w3.org/TR/css-font-loading/">CSS Font Loading Module</a>で定義されているウェブ標準APIや<a href="https://github.com/typekit/webfontloader">Web Font Loader</a>は利用しておらず、クラスによる制御もしていない。これはフォントの読み込みを待つのにくらべ実装が簡単な点で大きく勝るが、フォントの読み込みに時間がかかると文字が読めなくなる可能性があるという欠点もある。</p>

<p>その欠点はウェブフォントが500KBを超えるあたりで表面化する。幸い<a href="https://github.com/bramstein/fontloader">CSS Font Loadingのpolyfill</a>がしばらく前に書き直されたようで、まずはこちらに期待すると良さそうだ。その一方で<a href="https://tabatkins.github.io/specs/css-font-display/">ウェブフォントの反映の仕方を制御するためのCSS仕様</a>も提案されているようで、こちらだと更にコストは下がるだろう。未来は明るい。</p>]]></content:encoded>
    </item>

    <item>
      <title>v6.78.0</title>
      <link>http://hail2u.net/blog/webdesign/version-six-point-seventy-eight-point-zero.html</link>
      <description>画像をなくすみたいなことをやっていた（画像をなくしたいわけではない）。あんまり変わってないけれども、画像がなくなると文字の大きさのバリエーションが非常に目立つようになるので、全体的に控えめにしたりもしてた。その過程でいろいろなところで利用していた枠線もほとんどなくなった。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/version-six-point-seventy-eight-point-zero.html</guid>
      <pubDate>Sun, 13 Sep 2015 07:34:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure >
<a href="http://hail2u.net/images/blog/version-six-point-seventy-eight-point-zero.png"><img alt="v6.78.0" height="627" src="http://hail2u.net/images/blog/version-six-point-seventy-eight-point-zero.png" width="1200"></a>
</figure>

<p>画像をなくすみたいなことをやっていた（画像をなくしたいわけではない）。あんまり変わってないけれども、画像がなくなると文字の大きさのバリエーションが非常に目立つようになるので、全体的に控えめにしたりもしてた。その過程でいろいろなところで利用していた枠線もほとんどなくなった。</p>

<p>黄金比もついにあきらめ<code>1.7</code>まで上げた。<code>line-height</code>プロパティーの値として考えると、ヒラギノでは良くなって、メイリオでは悪くなった。游やNoto Sans JP、M+あたりを想定するとこれも良くなっているので、メイリオのことは忘れたい。</p>

<p>ついでにリンクに使っていたアクセント色をちょっと変えて、リンクでも背景色とのコントラストがWCAG 2 AAに合格するようにもしておいた。数値としては<code>4.67</code>なのでギリギリ合格してるけれど、リンクの視認性そのものは下がったような気がする。これは僕の目が青をうまく見えてないだけかもしれない。</p>

<hr>

<p>最近、紺色の識別率がガクッと落ちてる。ブライトなカラーパレットが推奨されているのは、ウェブにおけるリード・デザイナーの高年齢化が進み、発言力のある彼らに最適化されているのではないだろうか。とか3秒くらい考えた。</p>]]></content:encoded>
    </item>

    <item>
      <title>Drawic v2.11.0</title>
      <link>http://hail2u.net/blog/webdesign/drawic-v2.11.0.html</link>
      <description>Drawicへ使い始めたInstapaperを始めFeedly、CloudFlare、Slackとウェブサービスのアイコンを4つ追加してv2.11.0に更新した。もう#でSlackみたいな感じになっててすごい。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/drawic-v2.11.0.html</guid>
      <pubDate>Wed, 09 Sep 2015 06:14:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure >
  <a href="http://hail2u.github.io/drawic/"><img alt="Instapaper, Feedly, CloudFlare, and Slack" height="627" src="http://hail2u.net/images/blog/drawic-v2.11.0.png" width="1200"></a>
</figure>

<p><a href="http://hail2u.github.io/drawic/">Drawic</a>へ使い始めた<a href="https://www.instapaper.com/">Instapaper</a>を始め<a href="https://feedly.com/">Feedly</a>、<a href="https://www.cloudflare.com/">CloudFlare</a>、<a href="https://slack.com/">Slack</a>とウェブサービスのアイコンを4つ追加してv2.11.0に更新した。もう#でSlackみたいな感じになっててすごい。</p>

<p>いつの間にやら80個目だ。108個くらいまでは作りたい。その頃にはEPSとかいうフォーマットが絶滅してますように。</p>

<p>あと、こっそりアレをアレしてv2.11.1になってたりもする。</p>]]></content:encoded>
    </item>

    <item>
      <title>丸いチェックボックス</title>
      <link>http://hail2u.net/blog/webdesign/rounded-checkboxes.html</link>
      <description>Checkboxes Are Never Roundという記事を読んでいた。チェックボックスの見た目をちょっと変えて丸くしてしまうと、ラジオボタンとまったく変わらなくなり、ユーザーがその機能に戸惑う可能性があるので、知覚されたアフォーダンスを破壊するという風に読んだ。丸いチェックボックスだけでなく、下線だけのテキスト入力コントロールやクリックしてもフォーカスの移らないラベルなども似た問題を持つ。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/rounded-checkboxes.html</guid>
      <pubDate>Sun, 06 Sep 2015 02:48:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><a href="http://danieldelaney.github.io/checkboxes/">Checkboxes Are Never Round</a>という記事を読んでいた。チェックボックスの見た目をちょっと変えて丸くしてしまうと、ラジオボタンとまったく変わらなくなり、ユーザーがその機能に戸惑う可能性があるので、<a href="https://ja.wikipedia.org/wiki/%E3%82%A2%E3%83%95%E3%82%A9%E3%83%BC%E3%83%80%E3%83%B3%E3%82%B9#.E3.83.8E.E3.83.BC.E3.83.9E.E3.83.B3.E3.81.AE.E8.AA.A4.E7.94.A8">知覚されたアフォーダンス</a>を破壊するという風に読んだ。丸いチェックボックスだけでなく、下線だけのテキスト入力コントロールやクリックしてもフォーカスの移らないラベルなども似た問題を持つ。</p>

<p>こういった妙なフォーム・コントロール要素は、実際に操作するまで気づくことはないので、問題として表面化することはなかなかない。そのため作る方が常に意識して避けないとならない。フォーム・コントロール要素の見た目はいじらないくらいに意識しても良い、と僕は考えている。</p>

<p>また、他のプラットフォームのフォーム・コントロール要素に似せたがその持つ機能を完璧に再現出来ていないようなものも同じような意味で問題がある。iOSなどで使われているドラッグできる形式のトグル・ボタンに似せてあっても、ドラッグできないのでは使いやすさという点に大きく疑問が残るだろう。</p>]]></content:encoded>
    </item>

    <item>
      <title>Uptime RobotからiOSの通知へ</title>
      <link>http://hail2u.net/blog/internet/uptime-robot-to-ios-notification.html</link>
      <description>Uptime Robotはウェブサイトが落ちた時に通知してくれるが、その通知方法は限られている。スマホ・アプリがあって通知で受け取れることができれば良さそうだが、残念ながら公式アプリはない。そこで対応しているWebhookとIFTTTのMakerチャンネルを使うことでiOSの通知に送ることにした。</description>
      <category>Internet</category>
      <guid isPermaLink="true">http://hail2u.net/blog/internet/uptime-robot-to-ios-notification.html</guid>
      <pubDate>Wed, 02 Sep 2015 05:38:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p><a href="https://uptimerobot.com/">Uptime Robot</a>はウェブサイトが落ちた時に通知してくれるが、その通知方法は限られている。スマホ・アプリがあって通知で受け取れることができれば良さそうだが、残念ながら公式アプリはない。そこで対応しているWebhookと<a href="https://ifttt.com/maker">IFTTTのMakerチャンネル</a>を使うことでiOSの通知に送ることにした。</p>

<p>IFTTT側でMakerチャンネルの設定が終わってるとすると、まずはUptime Robot側でMy SettingsからAlert Contactを追加する。</p>

<figure>
<table>
<thead>
<tr>
<th>設定</th>
<th>値</th>
</tr>
</thead>
<tbody>
<tr>
<td>Friendly Name</td>
<td>IFTTT Maker</td>
</tr>
<tr>
<td>URL to Notify</td>
<td>https://maker.ifttt.com/trigger/uptimerobot/with/key/{secret_key}?</td>
</tr>
<tr>
<td>JSON</td>
<td>{&quot;value1&quot;:&quot;<mark>monitorFriendlyName</mark>&quot;,&quot;value2&quot;:&quot;<mark>alertDetails</mark>&quot;}</td>
</tr>
</tbody>
</table>
<figcaption>Alert Contact Information</figcaption>
</figure>

<p>URLではイベントとして<code>uptimerobot</code>などを指定しておく(落ちた時と復活した時の両方で送られると思うので、<code>website_down</code>とかは付けないほうが良い)。また最後に<code>?</code>をつける必要がありそう。Makerチャンネルには3つまでしか値を渡せないので、モニターの名前(<code>monitorFriendlyName</code>)とエラーの詳細(<code>alertDetails</code>)が確定だろう。後で修正することはできないので、間違えた場合は消して作りなおす必要がある。</p>

<p>作り終わったら忘れずに各モニターの設定から通知先でIFTTT Makerにチェックを入れておく。</p>

<p>IFTTTレシピはトリガーがMakerチャンネルでアクションがIF Notificationsチャンネル（最近iOSとAndroidの通知チャンネルが統合された）になる。Makerチャンネル側では先ほどAlert ContactのURLで指定したイベント名<code>uptimerobot</code>を指定するだけだ。IF Notificationチャンネルの設定は以下のような簡単なものしか作ることはできなそうだ。IFアプリ経由での通知なので、Uptime Robotからの通知であることがすぐわかるようにラベルは付けておいた方が良い。</p>

<figure>
<table>
<thead>
<tr>
<th>フィールド</th>
<th>値</th>
</tr>
</thead>
<tbody>
<tr>
<td>Notification</td>
<td>Uptime Robot: {{Value1}} ({{Value2}})</td>
</tr>
</tbody>
</table>
<figcaption>Action: Send a notification</figcaption>
</figure>

<p>これでウェブサイトが落ちた場合にiPhone等へ次のような通知が送られてくる。</p>

<blockquote>
<p>Uptime Robot: Hail2u.net (HTTP 409 - Conflict)</p>
</blockquote>

<p>もちろん回復した時にもちゃんと通知が送られる。</p>

<blockquote>
<p>Uptime Robot: Hail2u.net (HTTP 200 - OK)</p>
</blockquote>

<p>GitHub Pagesが落ちた時やCloudFlareが調子悪い時にちゃんと通知が来るところまでは確認した。</p>]]></content:encoded>
    </item>

    <item>
      <title>夢</title>
      <link>http://hail2u.net/blog/misc/dreaming-20150827.html</link>
      <description>天の声に「CSSの基本は発声から」と言われる。朝起きたらまず裏の神社にお参りし、今日も一日CSSをうまく書けるように大きな声でお祈りすることが義務付けられる。恥ずかしいのでサボったらテキスト・エディターでCSSファイルが開けなくなった。基本大事だなーと思ったところで目が覚める。</description>
      <category>Misc.</category>
      <guid isPermaLink="true">http://hail2u.net/blog/misc/dreaming-20150827.html</guid>
      <pubDate>Mon, 31 Aug 2015 01:18:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>天の声に「CSSの基本は発声から」と言われる。朝起きたらまず裏の神社にお参りし、今日も一日CSSをうまく書けるように大きな声でお祈りすることが義務付けられる。恥ずかしいのでサボったらテキスト・エディターでCSSファイルが開けなくなった。基本大事だなーと思ったところで目が覚める。</p>

<p>少し前にCSSかるたみたいな夢も見た。読む人が「display」って読むと、並べてある<code>block</code>や<code>inline</code>などを取れる。取れる札が複数あるかるた、ゲームとして成立しないことがわかった。</p>]]></content:encoded>
    </item>

    <item>
      <title>物の価値</title>
      <link>http://hail2u.net/blog/misc/the-value-of-things.html</link>
      <description>遺品の整理をやっているわけだが、親(や多分配偶者)のものにはまったく価値が見いだせなくて、捨てるしかどうしようもない感じだ。思い出が多少あるものがあっても、明らかに着ることのできない洋服だったりする。袖が足らなかったり、ウエストが10cmくらい余ったり。</description>
      <category>Misc.</category>
      <guid isPermaLink="true">http://hail2u.net/blog/misc/the-value-of-things.html</guid>
      <pubDate>Thu, 27 Aug 2015 09:57:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure >
  <a href="http://hail2u.net/images/blog/23-year-old-t-shirts.jpg"><img alt="23年モノのTシャツ" height="2360" src="http://hail2u.net/images/blog/23-year-old-t-shirts.jpg" width="2360"></a>
</figure>

<p>遺品の整理をやっているわけだが、親(や多分配偶者)のものにはまったく価値が見いだせなくて、捨てるしかどうしようもない感じだ。思い出が多少あるものがあっても、明らかに着ることのできない洋服だったりする。袖が足らなかったり、ウエストが10cmくらい余ったり。</p>

<p>サイズが問題にならない鞄類は取っておいても良さそうだったが、あまりきれい好きではなかったため、酒のシミや匂いで厳しかった。唯一、一澤帆布のトートバッグは大丈夫そうだったので洗濯して使うことにした。あとはスーツケースか。服もカシミアのニットだけは貰って着ようと思う。</p>

<hr>

<p>多くの場合物の金銭的な価値は買った時点で失われ、利用価値と利用に伴う思い入れだけになる。最初の画像は僕が高校生の頃に買ったTシャツでなんだかんだで23年着ている。購入当時既に古着だったので、最低でも30年物くらいだと思う。だからといっても特に価値があるわけではなく、着やすいわけでもない。色は悪くないけれど、悪くはない程度だ。穴でもできない限りは捨てることなく毎夏着ることだろう。でも僕が死んだら間違いなく捨てられる。</p>

<p>いつ死んでも良いように身の回りのものを極限まで減らすのは馬鹿げていると思うけれど、明らかに遺族に負担がかかりそうなものは出来うる限り整理しておくくらいの気は使っても良いのかもしれない。服とかは捨てるのがまぁまぁ大変(そもそもまとめるのが大変であるとか、うちの自治体では雨降ってると出せないとかある)なので、着ないものはなるべく整理しておいた方が良さそうだ。</p>

<p>趣味のものについてはどうしようもないので、その整理に余力を残してやるためにも……という意味もある。生前にどうにかしろとか言うとケンカどころか警察沙汰になりかねないのでやめた方が良い。ようやく5万枚のデジタル写真の処理が終わって、あとは50PくらいあるB5サイズのアルバム30冊とスライド化されている3万枚くらいのネガの処理に移る。</p>

<hr>

<p>葬式直後くらいから何回か「不要な服や靴を無料で回収いたします」という主旨の電話が頻繁にかかってくるようになった。葬儀屋か火葬場、市役所あたりから伝わる謎のネットワークがあるのだろうか。</p>]]></content:encoded>
    </item>

    <item>
      <title>喪</title>
      <link>http://hail2u.net/blog/misc/mourning.html</link>
      <description>ゲーム期じゃなかった。父親が死んだので色々やったりしてた。あぁ誕生日だ。ひどい言い方になるが70を超えた辺りでそろそろとか考えたことはあったような気はするけど、僕が40になる前に死ぬとも思ってなかったし、こう突然死ぬとは思ってなかった。</description>
      <category>Misc.</category>
      <guid isPermaLink="true">http://hail2u.net/blog/misc/mourning.html</guid>
      <pubDate>Thu, 23 Jul 2015 00:12:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>ゲーム期じゃなかった。父親が死んだので色々やったりしてた。あぁ誕生日だ。ひどい言い方になるが70を超えた辺りでそろそろとか考えたことはあったような気はするけど、僕が40になる前に死ぬとも思ってなかったし、こう突然死ぬとは思ってなかった。</p>

<p>漠然とガンでしばらく闘病してから死ぬとか、痴呆症になって徘徊老人となって公共放送で探したりする羽目になって介護施設に入りそこで死ぬとかそういうことは考えていた。でも実際にはそういう形ではなく、よくわからない形で倒れ、そのまま意識を回復することなく死んでしまった。70を超えるまで特に大病をすることもなく普通に生きていたように見えたので、それなりに死が見え隠れするような状況になって、徐々に死ぬようなことは考えていたような気がする。老々介護とかそういうのだ。</p>

<p>思ったのは普通にあっさりと死ぬのはなかなか難しいのかなということだ。普通に生活している中で「死んだ、あっはい」みたいにはいかない。何か重い病気になった場合でも長い闘病生活(看病生活)の後に死ぬことになるだろうし、痴呆症になった場合はもっと色々あった末に死ぬ。どちらもあっさりからはほど遠い。倒れて死んだらあっさりだろと思う人は多いけど、時間的には確かに短いが、その密度はかなりのものだった。</p>

<p>倒れて病院に運ばれてからどうなるかまったくわからないままただひたすら待つ。父親の場合はかなりひどい状態でまず1日は持たないだろうという話だったが、場合によっては意識がないまま数日どころかもっとということもありうる。その間、何もできることはない。ただ奇跡が起こるか死ぬかを待つだけだ。</p>

<p>死んでもそれで終わりというわけではなかった。死因がはっきりと特定できない場合、遺体は検視に回される。そして警察署で検視の完了をひたすら待つことになった。1日はかからなかったが、ほぼ18時間ほど警察官から事件性のあるなしを確定するために質問されつつただ待った。そして死亡時の担当医の都合に合わせて、翌日死体検案書を受け取ってようやく死後の作業に入ることができた。</p>

<p>交通事故など犯罪性のある事故ではもっと大変なのだろうということを考えると、普通にあっさりと死ぬことは難しい。というかほとんど無理そうだ。</p>

<hr>

<p>今思うのは平均寿命とか健康寿命とか徘徊老人とか老々介護とか特別養護老人ホームといった話題がただただ腹ただしい。もちろん八つ当たりなのだけど。70過ぎるまで大病もせずに生きていれば平均寿命を超えて生きるものだとまんまとミスリードされていたことが腹ただしいのか、それでも生きているだけ幸せなんじゃないかみたいな腹ただしさなのか。よくわからない。</p>

<hr>

<p>実は人が死んだ瞬間というのに立ち会ったのは生まれてはじめてかもしれない。それまで眠っていたような感じだった父親が突然顔色が悪くなり始めた後、少し痙攣し、寝ているのとはまったく違う感じになった。その時はこの瞬間を忘れることはできないと思っていたけど、1ヶ月も経たないうちにうまく思い出せなくなってきた。想像していた以上にショックは大きかったようだ。</p>

<p>こういうことも遺品を整理している中で、もう少し変わってくるのかもしれない。遺品整理の最大の壁は1冊辺り1000枚以上はあるスライド化されたネガ(白い厚紙とかに1枚ずつ挟まれたやつ)のファイルっぽい。50冊以上ある。本もものすごい数あるけれど、これはそのうち読もうと思っている。手始めに読んだことのなかった新共同訳聖書を読んでいる。ハードカバーですごい重い。</p>

<p>このすっきりしない感じもそのうち変わってくるのだろうか。たまに来る父親宛ての郵便物にまだ軽いショックを受けたりもする。</p>]]></content:encoded>
    </item>

    <item>
      <title>dns-prefetchとpreconnect、そしてprefetchやprerenderとpreloadの併記</title>
      <link>http://hail2u.net/blog/webdesign/dns-prefetch-preconnect-prefetch-prerender-preload.html</link>
      <description>2014年10月より標準化作業が公開されたResource Hints仕様により、既存のrel=dns-prefetchとrel=prefetch、そしてrel=prerenderは置き換えられる可能性がある。この置き換えが起こる可能性は決して高くはなさそうなので、実装されているもののままでも構わないと思うが、link要素のrel属性は複数の値を取ることができるので、同時指定しても良い。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/dns-prefetch-preconnect-prefetch-prerender-preload.html</guid>
      <pubDate>Wed, 24 Jun 2015 09:14:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p>2014年10月より標準化作業が公開された<a href="http://www.w3.org/TR/resource-hints/">Resource Hints仕様</a>により、既存の<code>rel=dns-prefetch</code>と<code>rel=prefetch</code>、そして<code>rel=prerender</code>は置き換えられる可能性がある。この置き換えが起こる可能性は決して高くはなさそうなので、実装されているもののままでも構わないと思うが、<code>link</code>要素の<code>rel</code>属性は複数の値を取ることができるので、同時指定しても良い。</p>

<p><code>rel=dns-prefetch</code>は<code>rel=preconnect</code>と完全に対応しているので、そのまま追加してやるだけになる。</p>

<pre><code >&lt;link
  href=&quot;//example.com&quot;
  rel=&quot;preconnect dns-prefetch&quot;&gt;
</code></pre>

<p><code>rel=prefetch</code>と<code>rel=prerender</code>はResource Hints仕様では<code>rel=preload</code>に統合される。事前にレンダリングまでするかどうかは<code>loadpolicy</code>属性を併用することで制御する。</p>

<pre><code >&lt;link
  href=&quot;http://example.com/fetch&quot;
  loadpolicy=&quot;next <mark>inert</mark>&quot;
  rel=&quot;preload prefetch&quot;&gt;
&lt;link
  href=&quot;http://example.com/render&quot;
  loadpolicy=&quot;next&quot;
  rel=&quot;preload prerender&quot;&gt;
</code></pre>

<p><code>rel=preload</code>はデフォルトで事前レンダリングを行うように支持するということになっており、それを無効にするためには<code>loadpolicy</code>属性で不活性やサボるなどという意味を持つ<code>inert</code>を指定する。つまり<code>rel=prefetch</code>と同じ挙動にしたい場合は<code>inert</code>を追加するということになる。</p>

<p><code>rel=preload</code>では他に<code>pr</code>属性を使って<del>読み込みのプライオリティー</del>を、<code>as</code>属性を使って読み込むリソースの形式を指定することもできるようになっている。<del>特にウェブアプリではその動線の予測しやすさから、事前読み込みを駆使することになると思うので、<code>pr</code>属性を使ってうまくプライオリティーを制御することでより効果的なプリロードを行えることだろう。</del>対して<code>as</code>属性での形式の指定は、画像やフォントの場合は択一式で提供することも多いはずなので、<code>html</code>以外を使う機会はあまりなさそうだ。</p>

<hr>

<p>あとは実際にうまく機能してくれるかどうかということになる。</p>

<aside >
<p>Chrome 43では開発者ツールのネットワークで<code>rel=dns-prefetch</code>や<code>rel=prefetch</code>の動作を確認でき、タスク マネージャ(Chromeのそれ)でレンダリング・プロセスが走っていることにより<code>rel=prerender</code>の動作を確認できる。</p>
</aside>

<p><code>rel=dns-prefetch</code>と<code>rel=preconnect</code>の併記は、Firefox 38及びChrome 43、Internet Explorer 11でちゃんと名前解決を行っているらしいことが確認できた。</p>

<p><code>rel=prefetch</code>と<code>rel=prerender</code>の両方に対応しているChrome 43とInternet Explorer 11ではどちらの併記方法もうまく動いているらしきことは確認できた。Firefox 38でも<code>rel=prefetch</code>の方の併記は問題ないようだった。</p>

<hr>

<p>速やかに<code>rel=preconnect</code>と<code>rel=preload</code>へと移行されるかというと大きく疑問が残る。Resource Hints仕様が現状の実装に比べて大きく強化されていることもそうだが、実装の足並みがバラバラで各自が制限や拡張を行っていることや、プリフェッチ系の機能への根強い抵抗があることもある。少なくともマルチ・プロセス化したFirefoxが<code>rel=prerender</code>相当の機能を実装するくらいになるまではどうなるかの予想は難しいだろう。</p>

<p>ともあれ現時点では併記しておくというのは悪くない。運良くResource Hints仕様へ揃う可能性もなくはないからだ。</p>]]></content:encoded>
    </item>

  </channel>
</rss>
