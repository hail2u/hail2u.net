<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
  xml:lang="ja"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:creativeCommons="http://backend.userland.com/creativeCommonsRssModule"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Weblog - Hail2u.net</title>
    <link>http://hail2u.net/blog/</link>
    <description>ウェブ制作やウェブ標準の話題が中心ですが、それに限らず備忘録や日々の記録までを含めることで、10年以上続けることができたウェブログです。Blosxomを使って作られています。</description>
    <language>ja</language>
    <managingEditor>hail2u@gmail.com (Kyo Nagashima)</managingEditor>
    <lastBuildDate>Tue, 16 Jun 2015 10:01:42 +0900</lastBuildDate>
    <generator>blosxom v2.1.2+dev</generator>
    <atom:link rel="self" href="http://hail2u.net/blog/feed"/>
    <atom:link rel="hub" href="https://pubsubhubbub.appspot.com/"/>
    <creativeCommons:license>http://creativecommons.org/licenses/by-nc/3.0/</creativeCommons:license>


    <item>
      <title>Chromeとpre要素</title>
      <link>http://hail2u.net/blog/webdesign/pre-on-chrome.html</link>
      <description>しばらく前から特定のフォントをpre要素へ指定すると、Chromeのみでほとんど意味のない縦スクロールバーが表れるという現象に悩まされている。とは言ってもWindows以外ではもはやスクロールバーが見えることはないので、事実上WindowsのChromeユーザーのみが影響を受ける。DirectWriteが有効になったChrome 37あたりから頻発するようになった印象だ。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/pre-on-chrome.html</guid>
      <pubDate>Tue, 16 Jun 2015 10:01:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure >
  <a href="http://hail2u.net/images/blog/pre-on-chrome.png"><img alt="謎の縦スクロールバー" height="627" src="http://hail2u.net/images/blog/pre-on-chrome.png" width="1200" ></a>
</figure>

<p >しばらく前から特定のフォントを<code>pre</code>要素へ指定すると、Chromeのみでほとんど意味のない縦スクロールバーが表れるという現象に悩まされている。とは言ってもWindows以外ではもはやスクロールバーが見えることはないので、事実上WindowsのChromeユーザーのみが影響を受ける。DirectWriteが有効になったChrome 37あたりから頻発するようになった印象だ。</p>

<p>修正は簡単で、上下どちらかに<code>padding</code>プロパティーを追加してやれば良い。</p>

<pre><code >pre {
  padding-bottom: 1px;
}
</code></pre>

<p>実害はあまりないように書いてしまったけれど、Mobile SafariなどWebKit系でもさり気なく発生しているような気がする。発生しても見た目は問題ない(スクロールバーが見えないので)が、ちょうどそこでスワイプしてスクロールしようとするとうまくスクロールされなかったりする。</p>

<p>とにかく再現条件がまったくわからない。このウェブサイトでは発生しているので、上記CSSによってアドホックに解決している。</p>]]></content:encoded>
    </item>

    <item>
      <title>パッケージのスコープ化</title>
      <link>http://hail2u.net/blog/software/scoped-npm-packages.html</link>
      <description>2015/04/15よりnpmレジストリーでパッケージのスコープ化が行えるようになった。パッケージのスコープ化は名前の衝突を回避することが主な目的のような取り上げられ方だが。僕は今まで色々な理由でnpmレジストリーへは非公開にしてGitHub経由でインストールすることを推奨していたようなパターンで使うのが良さそうだという感想を持った。</description>
      <category>Software</category>
      <guid isPermaLink="true">http://hail2u.net/blog/software/scoped-npm-packages.html</guid>
      <pubDate>Mon, 15 Jun 2015 11:46:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p >2015/04/15よりnpmレジストリーでパッケージのスコープ化が行えるようになった。パッケージのスコープ化は名前の衝突を回避することが主な目的のような取り上げられ方だが。僕は今まで色々な理由でnpmレジストリーへは非公開にしてGitHub経由でインストールすることを推奨していたようなパターンで使うのが良さそうだという感想を持った。</p>

<p><code>&quot;private&quot;: true</code>からスコープ化したパッケージへの変換は2ステップで行う。</p>

<section>
<h2>package.jsonの更新</h2>

<ul>
<li><code>&quot;private&quot;: true</code>の削除</li>
<li><code>name</code>フィールドの値へプリフィックスを追加</li>
</ul>

<p>プリフィックスはなんでも良いようだが、通常はnpmのユーザー名を使うと良いだろう。僕は<code>@hail2u/</code>にしておいた。GitHubオーガニゼーション単位でスコープ化したい場合はその名前の方が良い。</p>
</section>

<section>
<h2>公開</h2>

<p>npmレジストリーへの公開にはオプションを追加する必要がある。特にインストールへ制限は設けないのなら<code>public</code>で良い。</p>

<pre><samp>$ <kbd>npm publish <mark>--access public</mark></kbd>
</samp></pre>

<p>このオプションの指定は最初に<code>npm publish</code>する時だけ必要になるようだ。</p>
</section>

<hr>

<p>特にnpmパッケージ自体を非公開にしたいわけではないけれど、プライベートにすることはたまにある。それほど本気でずっと使う予定もないとか、npmレジストリーの名前を占拠したくないとか、その場合にも変な名前を付けるのも嫌だとか、環境に強く依存していて自分専用に近いものとか。</p>

<p>こういった半プライベートなnpmパッケージをGitHub経由でインストールする(してもらう)というアプローチは、短期的にはあまり問題ない。しかしインストールはやはり遅く、特にCI環境下では致命的といえる。また、バージョン指定が特殊で面倒な感じになりやすい。そのため常に最新版を使うような運用にしてしまいがちで、あっと思ったら環境が壊れたということになりうる(やった)。</p>

<p>スコープ化しておくと通常のnpmパッケージとほとんど変わらず扱える。運用も同じように行うことになるので、GitHub経由特有の問題からは解放され、npmレジストリーとnpmパッケージそのものの問題に集約されることになる。問題が減るわけではないが、少なくとも問題の原因は減るので、その究明は楽になるだろう。</p>]]></content:encoded>
    </item>

    <item>
      <title>OGPとlink要素</title>
      <link>http://hail2u.net/blog/webdesign/ogp-and-link-element.html</link>
      <description>HTTPS化の準備を始めるにあたって、HTMLで内部的に利用しているURLを対応するのは簡単だ。すべて相対URLに書き換えるだけで対応することができる。その相対URLの書き換えもパスの位置を考慮して最短にする必要もなく、//で始まる相対URLで行えば良い。aやimg要素はもちろん、scriptやlink要素も相対URLで問題ない。しかし外部から利用されるURLもどきではこの限りではない。例えばOGPなど利用することになるmeta要素では相対URLは使えず、OGPの仕様そのものでmeta要素に限定されており、そのパーサー実装のひとつであるFacebookでも解釈できない(できなかった)。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/ogp-and-link-element.html</guid>
      <pubDate>Sun, 14 Jun 2015 07:18:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p >HTTPS化の準備を始めるにあたって、HTMLで内部的に利用しているURLを対応するのは簡単だ。すべて相対URLに書き換えるだけで対応することができる。その相対URLの書き換えもパスの位置を考慮して最短にする必要もなく、<code>//</code>で始まる相対URLで行えば良い。<code>a</code>や<code>img</code>要素はもちろん、<code>script</code>や<code>link</code>要素も相対URLで問題ない。しかし外部から利用されるURLもどきではこの限りではない。例えばOGPなど利用することになる<code>meta</code>要素では相対URLは使えず、OGPの仕様そのもので<code>meta</code>要素に限定されており、そのパーサー実装のひとつであるFacebookでも解釈できない(できなかった)。</p>

<p>OGPはRDFa Liteだが、なぜか<code>meta</code>要素で記述すると決められている。<code>meta</code>要素ではURLの解決が行われないので、URLスキームは省略できない(仮にFacebookが解釈できるようになっていたとしてもそう書くべきではないだろう)。もちろんCMSやそれに類するものを使っていれば書き換えは機械的に行うことは可能だが、そういう問題ではないだろうし、書き換えた時点でユーザーのキャッシュが破棄されることにもなる。</p>

<p>OGPと似ているもののRDFa LiteのモドキですらないTwitter Cardsでは<code>link</code>要素を使えたりもするが、相対URLへの対応は挙動が不審だった。少なくとも画像(<code>twitter:image</code>)についてはパーサー自体は通すものの表示には対応してくれないようだ。</p>

<p>URLの変更は気軽に行われるべきではないので、それだけを考えていれば良かった時代ではこういう仕様でもあまり問題はなかった。しかしHTTPS化の有形・無形の圧力と欲求にさらされることで、こういったウェブサービスの仕様がフレキシブルに対応できないものとなっている点が表面化してきてしまった。</p>

<hr>

<p>結局はこちら側からはどうにもできないので、やるしかない。手元ではCMSの設定でURLスキームの切り替えを簡単に行えるように対応させつつあり、ようやく準備は完了してきた。しかしよくわからない人達が勝手に作った標準っぽいオレオレ仕様を考慮して苦労するのは割に合わないし、すっきりしない。</p>]]></content:encoded>
    </item>

    <item>
      <title>2015ロ06ゴ12</title>
      <link>http://hail2u.net/blog/webdesign/logo-20150612.html</link>
      <description>ロゴを変えた。ベースはそのままに消印っぽい枠を付け、反時計回りに20度回転させている。ウェブページでは透過背景に青で、Facebook他で使う画像は青背景に薄いベージュした。faviconの方はそのままでは潰れてしまうので、16px四方と32px四方のバージョンのみ外側の枠を削除したものにしている。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/logo-20150612.html</guid>
      <pubDate>Sat, 13 Jun 2015 06:27:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure >
  <a href="http://hail2u.net/images/blog/logo-20150612.svg"><img alt="消印っぽいやつ" height="627" src="http://hail2u.net/images/blog/logo-20150612.svg" width="1200" ></a>
</figure>

<p >ロゴを変えた。ベースはそのままに消印っぽい枠を付け、反時計回りに20度回転させている。ウェブページでは透過背景に青で、Facebook他で使う画像は青背景に薄いベージュした。faviconの方はそのままでは潰れてしまうので、16px四方と32px四方のバージョンのみ外側の枠を削除したものにしている。</p>

<p>SVGはスケーラブルだけれども、縮小した場合にはどうしても細部が潰れてしまう。反対に拡大した時は大丈夫かというと、今度は余白を始めとした全体的な印象が変化してしまう。SVGで作れば単純に拡大・縮小するだけで済むというのは、一筆書きで書けるような単純な図形や幾何学的な図形の組み合わせの場合には正しい。または逆に細部の詳細さが無視できる程度に複雑なイラストの場合にも正しいと言っても良いだろう。</p>

<p>しかし、若干複雑で細部にそれなりに詳細さを要求するようなケースではそううまくはいかない。具体的に言うと社名やキャッチコピー付きのロゴなどがそうだ。最近の傾向としてはロゴを単純化することで、細部が潰れても問題ないようにすることが多い。サイズによって複数のデザインを使い分けるのはコストがかかるが、周囲のコンテンツとのバランスは取りやすい。単純化するのはイマドキではあるが、それだけが解ではないということだ。</p>]]></content:encoded>
    </item>

    <item>
      <title>オペラ座の怪人</title>
      <link>http://hail2u.net/blog/media/the-phantom-of-the-opera.html</link>
      <description>5年ぶりくらいに読みたくなったので本箱を漁っていたけどなかったので買った。前に読んだのは創元推理文庫版だったと思うので、今度は角川文庫版にした。確かにずいぶんと読みやすい気がする。文体の古さを噛み砕きながらまじめにゆっくりと読むのも好きだけど、読みやすいと連続で読む気になったりして、楽なのも悪くないなと最近は感じる。</description>
      <category>Media</category>
      <guid isPermaLink="true">http://hail2u.net/blog/media/the-phantom-of-the-opera.html</guid>
      <pubDate>Fri, 12 Jun 2015 07:39:00 +0900</pubDate>
      <content:encoded><![CDATA[
<figure >
  <a href="http://www.amazon.co.jp/gp/product/4042840019/ref=as_li_ss_il?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4042840019&amp;linkCode=as2&amp;tag=hail2unet-22"><img alt="オペラ座の怪人 (角川文庫)" src="http://ecx.images-amazon.com/images/I/41JQWRT9N9L.jpg" ></a>
</figure>

<p >5年ぶりくらいに読みたくなったので本箱を漁っていたけどなかったので買った。前に読んだのは創元推理文庫版だったと思うので、今度は角川文庫版にした。確かにずいぶんと読みやすい気がする。文体の古さを噛み砕きながらまじめにゆっくりと読むのも好きだけど、読みやすいと連続で読む気になったりして、楽なのも悪くないなと最近は感じる。</p>

<p>ここ10年くらいで一気にこれと同時代の文学が再翻訳されつつある。あれであれなあれの事情が解消されたからか。僕は和洋を問わずだいたいこの辺りの時代の文学が好きなため、若干古めかしく読みづらいとも言える古い文体での翻訳も好き。古さを意識しながら読めるからとか、現代を忘れられるからとか。ただ再翻訳では誤訳や何かの都合で省かれた部分が修正されたりするため、気になって欲しくなったりするのでずるい。</p>

<hr>

<p>やっぱり災厄の町の新訳版が欲しくなってきた。完全な電子書籍時代になると、もしかしたらこういった新訳も無料か安価に手に入れられたりするようになるのかな。</p>]]></content:encoded>
    </item>

    <item>
      <title>PostCSSプラグイン</title>
      <link>http://hail2u.net/blog/coding/postcss-plugin.html</link>
      <description>PostCSS v4.1.0からプラグインAPIが実装され、postcss.plugin()でプラグインを作ることが推奨されるようになった。このガイドラインに従って作ることで、プラグイン間で一貫性が保たれ、エラーもわかりやすくなるというわけだ。一見良いとこずくめだが、それだけだとPostCSSプラグインの実行に常にPostCSSが必要になってしまう。Node.jsモジュールとして機能しているかというと微妙なところだ。</description>
      <category>Coding</category>
      <guid isPermaLink="true">http://hail2u.net/blog/coding/postcss-plugin.html</guid>
      <pubDate>Thu, 11 Jun 2015 08:05:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p ><a href="https://github.com/postcss/postcss/releases/tag/4.1.0">PostCSS v4.1.0</a>からプラグインAPIが実装され、<code>postcss.plugin()</code>でプラグインを作ることが推奨されるようになった。この<a href="https://github.com/postcss/postcss/blob/master/docs/guidelines/plugin.md">ガイドライン</a>に従って作ることで、プラグイン間で一貫性が保たれ、エラーもわかりやすくなるというわけだ。一見良いとこずくめだが、それだけだとPostCSSプラグインの実行に常にPostCSSが必要になってしまう。Node.jsモジュールとして機能しているかというと微妙なところだ。</p>

<p>仮に<a href="https://github.com/hail2u/node-csswring">CSSWring</a>が<code>postcss.plugin()</code>だけを使って作り直されたとしてみよう。</p>

<pre><code >var fs = require(&quot;fs&quot;);
var postcss = require(&quot;postcss&quot;);
var csswring = require(&quot;csswring&quot;);

var input = &quot;main.css&quot;;
var output = &quot;main.min.css&quot;;

postcss([
  csswring()
]).process(fs.readFileSync(input, &quot;utf8&quot;), {
  from: input,
  to: output
}).then(function (result) {
  fs.writeFileSync(output, result.css);
});
</code></pre>

<p>PostCSSプラグインなので、このようにPostCSSの使い方をちゃんと知って使わざるをえない。もちろん他のPostCSSプラグインと組み合わせることもあるので、最終的にはこういう利用に落ち着くことはありうる。しかしCSSWringの機能のみを必要とする場合にもこう書かざるをえないのは無駄が多い。Autoprefixerのようにこういった形でコアを書き、別にラッパーを提供するという手もあるが、メンテナンスの手間が倍増することは確実だ。</p>

<p>また必要なPostCSSのバージョンを調べて、手作業で依存を解決しなくてはならないことも欠点になる。CSSWring側の<code>package.json</code>ですでに依存バージョンを明示していることを効果的に利用することができない。</p>

<pre><code >var fs = require(&quot;fs&quot;);
var csswring = require(&quot;csswring&quot;);

var input = &quot;main.css&quot;;
var output = &quot;main.min.css&quot;;

var result = csswring.wring(fs.readFileSync(input, &quot;utf8&quot;), {
  from: input,
  to: output
});
fs.writeFileSync(output, result.css);
</code></pre>

<p>CSSWringではこのように標準的なNode.jsモジュールのように利用することができる。Promiseではないことを考慮しても、コードは短くなっている。そもそもとしてPostCSSプラグインとしての使い方を知らなくても、はっきり言うのならPostCSSの存在を知らなくても書けるようになっている。</p>

<p>またこのスクリプトの<code>dependencies</code>からPostCSSが不要にもなる。つまり依存管理をモジュール側に任せることができるわけだ。</p>

<hr>

<p>プラグイン・システムというような方向から見ると、そういうデザインだとも言えるだろう。だがあるNode.jsモジュールを使う時にその依存モジュールの使い方をも知らなくてはならないという見方をするとどうだろうか。そんなことは知らなくてもそれ単体で使えるようになっているべきではないだろうか。</p>

<p>プラグイン・システムのような独自の生態系がいくつかのルール付けによって守られるようになると、同時にそれを内包する生態系(ここではNode.jsとnpm)との間に囲いを築くことにもなる。その囲いが低く感じられるか高く感じられるかはなんとも言えない。深くその独自の生態系について知れば、必要な高さの囲いだと納得できるかもしれないが、万人にそれを求めるのは酷だろう。</p>

<p>もちろんPostCSSプラグインはまったく悪いものではないし、PostCSSのプロセッサーとしてのみ機能するモジュールを書く場合に最も良い選択であることは確かだろう。ただそれだけではなく、Node.jsモジュールとしても単体で使えるようなインターフェイスも用意しておくことで、もっと使いやすくなるはずだ。</p>]]></content:encoded>
    </item>

    <item>
      <title>無限スクロール向け雑なローディング画像</title>
      <link>http://hail2u.net/blog/webdesign/easy-loading-marker-for-infinite-scroll.html</link>
      <description>無限スクロールはちょくちょく実装することはあるが、追加するコンテンツの読み込みや挿入はともかく、ローディング画像の処理で悩むことがある。その表示の切り替えには実装と処理のどちらにおいてもそこそこコストがかかるからだ。かなり前に色々考えるのが面倒になり、常に表示しておくという雑な手をよく使うようになった。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/easy-loading-marker-for-infinite-scroll.html</guid>
      <pubDate>Wed, 10 Jun 2015 03:15:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p >無限スクロールはちょくちょく実装することはあるが、追加するコンテンツの読み込みや挿入はともかく、ローディング画像の処理で悩むことがある。その表示の切り替えには実装と処理のどちらにおいてもそこそこコストがかかるからだ。かなり前に色々考えるのが面倒になり、常に表示しておくという雑な手をよく使うようになった。</p>

<p >View Demo: <a href="http://hail2u.net/pub/test/634.html">Easy Loading Marker for Infinite Scroll</a></p>

<p>デモでは90%ほどスクロールすると無限スクロールっぽくコンテンツが少し時間をおいてから追加される。コンテナーである<code>#content</code>の最下部には常にローディング画像を背景画像として表示してあるので、特に操作することなく無限スクロールのためにコンテンツを読込中であることを示すことができる。SVGアニメーションでローディング画像を作ったためInternet Explorer 11では回らないが、おおまかにどういう挙動をするのかはわかることだろう。</p>

<p>こういった雑なローディング画像の実装には利点が3つ挙げられる。</p>

<ul>
<li>コンテンツの読み込み以外のコードを書く必要がなくなる</li>
<li>ローディング画像が必要(とされそう)な時に即表示される</li>
<li>レンダリングのコストを下げられる</li>
</ul>

<section>
<h2>コード</h2>

<p>単純にローディング画像の挿入と削除を担当するコードがなくなり、ローディング画像の状態を保存する必要もなくなる。アニメーションGIFではなくスケーラブルにしたい場合も、デモのようにSVGアニメーションで完結させれば、HTMLへ空要素の挿入が必要ない(CSSでやる場合は擬似要素のアニメーションという点でいろいろあるので空要素などが必要になる)。もちろんCSSのコードが単純明快になるという点も見逃せない。</p>
</section>

<section>
<h2>ローディング画像の表示</h2>

<p>常に表示されているので、パフォーマンスを考慮したスクロール・イベントの間引きによる若干の遅延に影響を受けない。もちろんコンテンツの挿入そのもの自体は影響を受けるが、ローディング画像の表示においては影響を受けず、長めにアニメーションするだけになる。</p>
</section>

<section>
<h2>レンダリング・コスト</h2>

<p>画面外で常にアニメーションをさせることにはそれなりにコストはあるが、突然DOMに要素を追加(リフローやリレイアウト)し、アニメーションを開始(アニメーションの初期化コスト)するよりは低い。デモの場合はSVG内で完結させており、GPUのサポートも期待できる。</p>
</section>

<hr>

<p>欠点としては無限スクロール中のエラーに対して弱いことだ。追加コンテンツの読み込みとローディング画像の表示が完全に分離しているので、エラーが起きた時だけ両者を連動させる必要が出てくる。追加コンテンツの読み込み側ではエラー時にクラスを振るだけに留め、ローディング画像の表示と同じく簡単なCSSで見えなくしてやるのが妥当か。</p>

<hr>

<p>無限スクロールにおいては、ローディング画像などを表示することなく必要そうになる前に読み込み挿入しておく方が実装としては理想に近い。しかしその理想を実現するまでには、コンテンツを送る側のパフォーマンスやいつ読み込み始めるかのタイミング、ユーザーの回線への負担など解決が必要な問題がいくつもある。まずは実装ということを考えると、この雑なローディング画像は面倒がなく、便利に使っている。</p>]]></content:encoded>
    </item>

    <item>
      <title>夢</title>
      <link>http://hail2u.net/blog/misc/dreaming-20150603.html</link>
      <description>近くに昨日できた山が噴火する。そこから直径5mくらいの岩が降ってくるので、必死で避ける。避ける。3時間くらい避けたら岩の代わりにコインが降ってくるようになった。「コインだ！金だ！」と思って触ったら死んだ。ところで目が覚めた。</description>
      <category>Misc.</category>
      <guid isPermaLink="true">http://hail2u.net/blog/misc/dreaming-20150603.html</guid>
      <pubDate>Tue, 09 Jun 2015 04:29:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p >近くに昨日できた山が噴火する。そこから直径5mくらいの岩が降ってくるので、必死で避ける。避ける。3時間くらい避けたら岩の代わりにコインが降ってくるようになった。「コインだ！金だ！」と思って触ったら死んだ。ところで目が覚めた。</p>

<p>噴火の夢は何回か見たことがあるけど、実際に噴火を間近で見たことがないため、現実味に欠ける。桃鉄の噴火イベントみたいにドドドドって音がして、しばらくしたら上から岩が降ってくるだけ。煙や灰がまったくないので避けやすい。岩も普通の岩で熱いとかもない。</p>]]></content:encoded>
    </item>

    <item>
      <title>list-style-type: "🆕";</title>
      <link>http://hail2u.net/blog/webdesign/list-style-type-string.html</link>
      <description>Firefox 39からlist-style-typeプロパティーで文字列が使えるようになる。今までは文字列を使おうとすると擬似要素経由で行うことになったため、デフォルトで要素の外側に配置されるリスト・マーカーと違和感のないように行うのはなかなか難しかった。そういった点が解決しやすくなったことや、Emojiを利用したリスト・マーカーなど、明快に広がる使い勝手の良さもあるが、他にも横並びのリストの区切りが作りやすくなる。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/list-style-type-string.html</guid>
      <pubDate>Mon, 08 Jun 2015 03:47:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p ><a href="https://developer.mozilla.org/en-US/Firefox/Releases/39">Firefox 39</a>から<code>list-style-type</code>プロパティーで文字列が使えるようになる。今までは文字列を使おうとすると擬似要素経由で行うことになったため、デフォルトで要素の外側に配置されるリスト・マーカーと違和感のないように行うのはなかなか難しかった。そういった点が解決しやすくなったことや、Emojiを利用したリスト・マーカーなど、明快に広がる使い勝手の良さもあるが、他にも横並びのリストの区切りが作りやすくなる。</p>

<p >View Demo: <a href="http://hail2u.net/pub/test/633.html">list-style-type: &quot;string&quot;</a></p>

<p>デモでは横並びのリストの区切りにMiddle Dot (<code>·</code>)を使っている。ウェブサイトのフッターにあるリンク・リストなどでよくみる形のものだ。擬似要素でやる場合は、<code>li</code>要素のスタイルのリセットに加えて擬似要素の追加が必要になるが、<code>list-style-type</code>プロパティーが使える場合はずっと簡単になる。</p>

<pre><code >li {
  float: left;
  list-style-position: inside;
  list-style-type: &quot; · &quot;;
}

li:first-child {
  list-style-type: &quot;&quot;;
}
</code></pre>

<p>擬似要素を使う場合と比べて少しシンプルに、そして直感的なコードになっていることと思う。リスト項目と区切りの間の空白も文字列でコントロールすることができるので、文字列ベースの区切りにはもってこいだろう。ただし連続した空白はもちろんまとめられるので、非改行スペース(<code>\a0</code>)をうまく使うときれいに調節することができる。</p>

<p>区切りに使える文字列の自由度はかなり高い。Emojiもそうだが、ユニコードで定義されている<a href="http://en.wikipedia.org/wiki/Unicode_symbols">多くのシンボル文字</a>を使うことももちろん出来る。サブセット化したアイコン・フォントとも相性が良いと考えられるが、それは素直にSVGにして<code>list-style-image</code>プロパティーで参照した方が良いだろう。</p>

<hr>

<p>この<code>list-style-type</code>プロパティーにおける文字列の利用は、随分前から仕様では定義されていた(<a href="http://www.w3.org/TR/2011/WD-css3-lists-20110524/">2011/05/24付けのWorking Draft</a>からのようだ)が、実装は今月にリリースをひかえるFirefox 39が最初となる。そのため気軽に使えるようになるまではかなりの時間がかかることだろう。このような具体的で実践的な利用例を挙げることで、実装が進むことを期待したい。</p>]]></content:encoded>
    </item>

    <item>
      <title>カラースキームのアップデート</title>
      <link>http://hail2u.net/blog/webdesign/updating-color-scheme.html</link>
      <description>このウェブサイトのカラースキームを少し変えた。ベースとなるアクセント・カラーを#1188bbから#278dd2と少し青を強くした。並べて比較するとわかるといった程度の違いで、ほとんど変わっていない。</description>
      <category>Web Design</category>
      <guid isPermaLink="true">http://hail2u.net/blog/webdesign/updating-color-scheme.html</guid>
      <pubDate>Sun, 07 Jun 2015 02:34:00 +0900</pubDate>
      <content:encoded><![CDATA[
<p >このウェブサイトのカラースキームを少し変えた。ベースとなるアクセント・カラーを<code style="background-color:#1188bb;color:#fff">#1188bb</code>から<code style="background-color:#278dd2;color:#fff">#278dd2</code>と少し青を強くした。並べて比較するとわかるといった程度の違いで、ほとんど変わっていない。</p>

<p>多くの場合、こういったカラースキームの微調整には長い期間が必要になる。短期間に比較で行うと、微妙な違いが強調されて認識されてしまうため、自分の認識と実際の変化に大きなズレが生じてしまう。第三者に何も言わず見せ、ブラインド・テストを行うとすんなりおかしいところが発見できるが、少人数で開発している場合はそういったフラットな状態で確認することは難しいので、長い期間をかけてじっくりと確認する必要がある。</p>

<p>今回は<code style="background-color:#1188bb;color:#fff">#1188bb</code>から<code style="background-color:#3399ff;color:#fff">#3399ff</code>までの間で色々試した結果、3ヶ月ほどで<code style="background-color:#278dd2;color:#fff">#278dd2</code>に落ち着いた。通常の背景とのコントラスト比は<code>3.42</code>で<code>4.5</code>にはかなり足らないが、本文に使うわけではないのでこれまで通り目をつぶっておく。</p>]]></content:encoded>
    </item>

  </channel>
</rss>
