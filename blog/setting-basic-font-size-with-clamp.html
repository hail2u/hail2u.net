<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8">
    <meta content="light dark" name="color-scheme">
    <meta content="same-origin" name="view-transition">
    <meta content="width=device-width, initial-scale=1" name="viewport">

    <title>clamp()関数を使った基本フォント・サイズの決定</title>

    <style>
      body {
        font-family: sans-serif;
        font-size: 112.5%;
        margin-block-end: 25svh;
      }

      pre {
        white-space: pre-wrap;
      }

      figure {
        margin-inline: 0;
      }

      img,
      svg {
        block-size: auto;
        max-inline-size: 100%;
      }
    </style>
  </head>

  <body>
    <p><time>2020-05-25</time></p>

    <h1>clamp()関数を使った基本フォント・サイズの決定</h1>

    <figure>
<img alt="_/‾。" height="1440" src="/img/blog/setting-basic-font-size-with-clamp.svg" width="1920">
</figure>

<p><code>calc()</code>や<code>clamp()</code>関数など、CSSの計算式では、<code>100vw</code>などから<code>%</code>をうまく作れない。そのため、<code>%</code>の基本フォント・サイズを描画領域に応じて決定することは難しいと考えていた。しかし、<code>%</code>を作れなくても、<code>100%</code>にピクセルを加える形でもいいことがわかった。そこで、最小で<code>100%</code>、最大で<code>125%</code>、その間は描画領域のサイズに応じてなめらかに上昇するという形の実装を、<code>clamp()</code>関数を使って行った。</p>

<p>このウェブサイトでは既に導入されているので、上記変化を確認することができる。ユーザーがどのようなフォント・サイズ設定をしていても、なめらかに変化し、うまく動いているようだ。また、ズームしても問題なく動き、フォント・サイズの変更とズームを組み合わせてもちゃんと動く。「なんでも<code>min()</code>、<code>max()</code>、<code>clamp()</code>関数でやってみよう！」というのは、今だけは正しい姿勢かもしれない。</p>

<section>
<h2>実装</h2>

<pre><code class="language-css">html {
  font-size: 112.5%;
  font-size: clamp(
    100%,
    (100vw - 640px) * 0.004 + 100%,
    125%
  );
}</code></pre>

<p>フォント・サイズの最小値と最大値は、<code>clamp()</code>関数の最小と最大を使うだけで、わかりやすい。フォント・サイズの上昇を開始するしきい値は、実装で<code>640px</code>としている部分で行う。基本フォント・サイズが変わるので、それに影響を受けない<code>px</code>単位などで行う必要があるだろう。上がり方の調整は、実装で<code>0.004</code>としている係数で行う。大きくすれば急激に、小さくすればゆるやかに上昇する。</p>

<p>真ん中の式はピクセルで出てきそうで不安だが、ユーザーの設定したフォント・サイズに加わるだけなので、それが尊重される方向で決まる。またこの実装そのままだと、例えば描画領域の幅が<code>480px</code>の時、真ん中の式は負の値を出すが、最小値の<code>100%</code>が使われるため、ユーザーの設定したフォント・サイズより小さくなったりはしない。</p>

<p>フォールバックは、しなければユーザーの設定に従うので、しなくてもいい。もしするなら、最小値と最大値の中間にしたりすると簡単だろう。この例だと<code>112.5%</code>になり、既定のフォント・サイズのままだと<code>18px</code>だ。個人的に一番好きなくらいの文字サイズというのもあるが、悪くない値だと思う。</p>
</section>

<hr>

<p>実際の変化をたどってみよう。既定の<code>16px</code>のままとすると、<code>125%</code>は<code>20px</code>になる。最大でそこまでなので、計算で決まるのは<code>4px</code>分だ。これが0.004に当たるため、<code>4px / 0.004 = 1000px</code>で到達する。つまり、描画領域が<code>640px + 1000px = 1640px</code>で<code>20px</code>になる。</p>

<p>じゃあユーザーがフォント・サイズを変更していたらどうだろう。Chromeの最小だと<code>9px</code>で、<code>125%</code>は<code>11.25px</code>になり、計算で決まるのは<code>2.25px</code>分だ。これが0.004に当たるので、<code>2.25px / 0.004 = 562.5px</code>で到達する。つまり、描画領域が<code>640px + 562.5px = 1202.5px</code>で<code>11.25px</code>になる。</p>

<p>逆に大きくした場合も考えてみよう。Chromeの最大だと<code>24px</code>で、<code>125%</code>は<code>30px</code>になり、計算で決まるのは<code>6px</code>分だ。これが0.004に当たるので、<code>6px / 0.004 = 1500px</code>で到達する。つまり、描画領域が<code>640px + 1500px = 2140px</code>で<code>30px</code>になる。</p>

<p>しかし、ユーザーの設定によって、上がり方が違うように思える。<code>%</code>という観点では、最小では<code>562.5px</code>しかかからないのに対して、最大だと<code>1500px</code>かかっており、3倍近くかかっている。その一方で、<code>px</code>という観点だと、どのサイズでも<code>250px</code>増えるごとに、基本フォント・サイズが<code>1px</code>上がっている。そう捉えると、上がり方は同じだとも言えるだろう。</p>

<hr>

<p>上で「ユーザーの設定が尊重される方向」と、あいまいに書いたが、完全な尊重ではないかもしれない。その理由はユーザーがフォント・サイズを設定している時、それをベースにしてほしいか、それとも<em>そのサイズで必ず表示してほしい</em>かの二通りの状況が考えられるからだ。前者なら、多分この<code>clamp()</code>関数は受け入れてもらえる。でも後者の場合、ユーザーは大きくなることすら許せないかもしれない。</p>

<p>ユーザー解析では、ユーザーがフォント・サイズを変えていることはすぐにわかるし、無視できない数、存在することもすぐにわかる。でも、そのユーザーたちが<em>なぜ変えているのか</em>まではわからない。固定的なサイズを望むユーザーには、もしかすると、あの実装するのを毛嫌いされるJavaScriptを使ったフォント・サイズ変更機能の方が、オプト・インで選択できる優れた解なのかもしれない。こういった時に必要になるのが、インクルーシブ・デザインなのだなと、ぼんやり考えていた。</p>
  </body>
</html>
